---
title: 八股文
date: 2024-03-15 21:03:14
tags:
---

# 三栏布局

> 左右两栏宽度固定，中间自适应
>
> flex
>
> > ```css
> > .outer {
> >   display: flex;
> >   height: 100px;
> > }
> > 
> > .left {
> >   width: 100px;
> >   background: tomato;
> > }
> > 
> > .right {
> >   width: 100px;
> >   background: gold;
> > }
> > 
> > .center {
> >   flex: 1;
> >   background: lightgreen;
> > }
> > ```
>
> 利用**绝对定位**，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值
>
> > ```css
> > .outer {
> >   position: relative;
> >   height: 100px;
> > }
> > 
> > .left {
> >   position: absolute;
> >   width: 100px;
> >   height: 100px;
> >   background: tomato;
> > }
> > 
> > .right {
> >   position: absolute;
> >   top: 0;
> >   right: 0;
> >   width: 200px;
> >   height: 100px;
> >   background: gold;
> > }
> > 
> > .center {
> >   margin-left: 100px;
> >   margin-right: 200px;
> >   height: 100px;
> >   background: lightgreen;
> > }
> > ```
>
> 利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式**，中间一栏必须放到最后：**
>
> > ```html
> > <div class='outer'>
> >   <div class='left'></div>
> >   <div class='right'></div>
> >   <div class='center'></div>
> > </div>
> > // .center的div必须放在最后
> > ```
> >
> > ```css
> > .outer {
> >   height: 100px;
> > }
> > 
> > .left {
> >   float: left;
> >   width: 100px;
> >   height: 100px;
> >   background: tomato;
> > }
> > 
> > .right {
> >   float: right;
> >   width: 200px;
> >   height: 100px;
> >   background: gold;
> > }
> > 
> > .center {
> >   height: 100px;
> >   margin-left: 100px;
> >   margin-right: 200px;
> >   background: lightgreen;
> > }
> > ```

# 垂直水平居中

> 子绝父相
>
> ```css
> .parent {    
>  position: relative;
> }
> .child {    
>  position: absolute;    
>  left: 50%;    
>  top: 50%;    
>  transform: translate(-50%,-50%);
> }
> ```
>
> flex
>
> ```css
> .parent {
>  display: flex;
>  justify-content:center;
>  align-items:center;
> }
> ```
>

# 三角形

> ```css
> div {
>     width: 0;
>     height: 0;
>     border: 100px solid;
>     border-top: 50px solid red;    
>     border-right: 50px solid transparent;    
>     border-left: 50px solid transparent;
> }
> ```
>
> ![image-20220905211204028](images/image-20220905211204028.png)

# css选择器及其权重

> ==!important==
>
> ==内联样式==
>
> ==id选择器== 100
>
> ==类选择器 属性选择器 伪类选择器== 10
>
> ==标签选择器 伪元素选择器== 1
>
> ==通配符* 兄弟选择器+ 子选择器> 后代选择器(空格)== 0
>
> ![image-20220906110907314](images/image-20220906110907314.png)

# 盒子模型

> ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4544d45b5a0c47a58c0c33a7d8fbac09~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)
>
> ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4040de9fef1a49f4ae0ae66039edcfe0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)
>
> 标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同：
>
> - 标准盒模型的width和height属性的范围只包含了content，
> - IE盒模型的width和height属性的范围包含了border、padding和content。
>
> 可以通过修改元素的box-sizing属性来改变元素的盒模型：
>
> - `box-sizeing: content-box`表示标准盒模型（默认值）
> - `box-sizeing: border-box`表示IE盒模型（怪异盒模型）

# html语义化和SEO

> HTML语义化， 简单说来就是让机器可以读懂网页的内容。
>
> 为什么要语义化?
>
> > 1. 页面结构: 使页面没有css的情况下，也能够呈现出很好的内容结构
> > 2. 有利于SEO: 爬虫依赖标签来确定关键字的权重，因此可以帮助爬虫抓取更多的有效信息
> > 3. 提升用户体验： 例如title、alt可以用于解释名称或者解释图片信息，以及label标签的灵活运用。
> > 4. 便于团队开发和维护: 语义化使得代码更具有可读性，让其他开发人员更加理解你的html结构，减少差异化。
> > 5. 方便其他设备解析: 如屏幕阅读器、盲人阅读器、移动设备等，以有意义的方式来渲染网页。
>
> 语义化与SEO的联系
>
> > 从搜索引擎的工作原理中，已经可以看出，标签语义化对爬虫的爬取以及索引器处理起着很大的作用。不管是在爬虫爬取时，或者是在索引器对网页进行分析处理时，让机器更加准确的将网页的内容分析并存储下来，这就需求我们用合理HTML标记以及其特有的属性去格式化文档内容。
>
> SEO
>
> > SEO（Search Engine Optimization）利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。将自己或自己公司的排名前移。
> >
> > 网站结构布局优化：尽量简单、开门见山，提倡扁平化结构、语义化
> >
> > > 控制首页链接数量，太少影响网站收录数量，太多影响体验降低权重
> > >
> > > 扁平化目录层次
> > >
> > > 导航优化，导航应该尽量采用文字方式，也可以搭配图片导航，但是图片代码一定要进行优化，标签必须添加“alt”和“title”属性，告诉搜索引擎导航的定位，做到即使图片未能正常显示时，用户也能看到提示文字。每个网页都加上面包屑导航，提升用户体验，方便爬虫了解网站结构
> > >
> > > 网站的结构布局
> > >
> > > 利用布局，把重要内容HTML代码放在最前，广告等不重要内容后置，方便爬虫
> > >
> > > 控制页面的大小，减少http请求，提高网站的加载速度，提升体验，方便爬虫
> > >
> > > 语义化
> > >
> > > 重要内容不用js输出，因为爬虫不读取js里面的内容，重要内容必须放在html里面
> >
> > 服务端渲染有利于seo
> >
> > > 我们的爬虫爬取的其实是网页里的标签内容，通过获取这些内容进行分析。假设我们的网站都是采用前后端分离进行开发，界面都需要用js去请求接口，等到接口返回之后才展示真个界面。那么我们的爬虫也许根本获取不到我们想要的内容。
> > >
> > > 而通过服务渲染，服务端将整个界面的数据填充完整之后，直接返回这个界面。第一，少了客户端请求的过程。第二，返回的直接就是整个界面。必然使爬虫能够更快，更准确的爬取到它想要的信息。
>
> 搜索引擎步骤
>
> > 网络爬虫通过特定规则跟踪网页的链接，从一个链接爬到另一个链接，把爬行的数据存入本地数据库
> >
> > 使用索引器对数据库中重要信息进行处理，如标题、关键字、摘要，或者进行全文索引，在索引数据库中，网页文字内容，关键词出现的位置、字体、颜色、加粗、斜体等相关信息都有相应记录。
> >
> > 索引器将用户提交的搜索词与数据中的信息进行匹配，从索引数据库中找出所有包含搜索词的网页，并且根据排名算法计算出哪些网页应该排在前面，然后按照一定格式返回给用户

# defer和async

> 没有defer或者async时，浏览器会立即加载并执行script，不会等待后续加载的文档元素，这样阻塞了后续文档的加载
>
> defer和async的加载不会阻塞页面的解析
>
> defer和async的区别如下:
>
> > 多个带defer的标签按照加载顺序执行，多个带async的标签，不能保证加载的顺序
> >
> > defer的js的加载是和文档解析并行进行(异步)，但js的执行是在文档的加载和解析完成之后，DomContentLoaded之前进行；async的js的加载和执行是和文档解析并行执行。
>
> ![请输入图片描述](images/bVcQV0)

# url、href、src、link&@import

> url
>
> > 统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。
>
> href
>
> > 页面解析到href不会停下，而是同时解析(==浏览器需要样式规则去画或者渲染页面，渲染过程可能会被暂停==)
>
> src
>
> > 页面解析到src会停下，先解析渲染执行完src后再继续解析，这就是为什么js要写在最下面
>
> link&@import
>
> > link属于html标签。@import在css中使用表示导入外部样式表
> >
> > 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载
> >
> > import只在IE5以上才能识别，而link是HTML标签，无兼容问题
> >
> > link方式的样式的权重 高于@import的权重
> >
> > link 支持使用javascript改变样式 （`document.styleSheets`），后者不可

# 伪类和伪元素

> - 伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：
>
> ```css
> p::before {content:"第一章：";}
> p::after {content:"Hot!";}
> p::first-line {background:red;}
> p::first-letter {font-size:30px;}
> 复制代码
> ```
>
> - 伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：
>
> ```css
> a:hover {color: #FF00FF}
> p:first-child {color: red}
> 复制代码
> ```
>
> **总结：** 伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。

# 外边距margin合并

> > 当上下两个块元素(兄弟关系)相遇时，如果上面的块元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则它们之间的垂直间距不是margin-bottom和margin-top的和，而是取两者之间较大值为垂直间距
> >
> > ==解决方案: 尽量只给一个盒子设置margin==
>
> > 当两个嵌套元素(父子关系)的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会取较大的外边距值进行布局，称之为坍缩现象
> >
> > 解决方案:
> >
> > 为父元素定义上边框border
> >
> > 为父元素定义上内边距padding
> >
> > ==为父元素添加overflow: hidden(此方案是最佳方案)==
> >
> > ==脱标(绝对定位、固定定位、浮动元素)的元素不会发生塌陷==

# BFC

> `Block Formatting Context`， 名为 "块级格式化上下文"
>
> 简单来说就是一个既不影响外界也不被外界影响的盒子
>
> 触发BFC的css
>
> > - overflow: hidden
> > - display: inline-block
> > - position: absolute
> > - position: fixed
> > - display: table-cell
> > - display: flex
>
> BFC的应用
>
> > 自适应布局(==因为BFC的区域不会与float重叠==)
> >
> > 清除浮动
> >
> > 解决垂直边距重叠(==父子关系的发生垂直边距重叠的两个盒子，将其中一个盒子进行BFC即可(注意此处overflow：hidden无效，尚未明白原因)==)(==父子关系的发生垂直边距重叠的两个盒子，也可以在中间加入空元素/伪类元素，并将空元素BFC即可==)(==兄弟关系的发生垂直边距重叠的两个盒子，将父元素BFC即可==)
>
> BFC原理
>
> > 1. BFC内部的盒子，会在垂直方向，一个接一个地放置。垂直方向上也会发生边距重叠。
> > 2. BFC就是页面上的一个独立容器，容器里面的子元素不会影响到外面的元素，外边的也不会影响里边的。
> > 3. BFC的区域不会与float重叠。
> > 4. 计算BFC的高度时，浮动元素也被计算在内。(==这样就可以通过给父元素加BFC解决因为子元素脱离文档流而导致的父元素高度塌陷==)

# flex: 1

> ![image-20220724210530530](images/image-20220724210530530.png)
>
> flex-grow
>
> > 这个属性规定了flex-grow项在flex容器中分配剩余空间的相对比例，剩余空间是 flex 容器的大小减去所有 flex 项的大小加起来的大小。如果所有的兄弟项目都有相同的 flex-grow 系数，那么所有的项目将剩余空间按相同比例分配，否则将根据不同的 flex-grow 定义的比例进行分配。
>
> flex-shrink
>
> > flex-shrink 属性指定了 flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值。
>
> flex-basis
>
> > flex-basis 指定了 flex 元素在主轴方向上的初始大小。如果不使用 [`box-sizing`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing) 改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的尺寸。

# 为什么要使用less等css预处理语言

> 为我们提供了诸如选择符嵌套、变量、运算、函数等功能
>
> 使得样式代码结构更加清晰美观、可读性更强、减少了开发者的无意义的机械重复劳动、
>
> 缺点是需要额外的配置工作、额外的编译成本、开发者额外的学习成本、调试更加麻烦(==相对于原生css==)

# css会阻塞Dom吗

> ![图：WebKit 主流程](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dea0a157f0646638848de5572d2bca8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)
>
> ![图：Mozilla 的 Gecko 呈现引擎主流程（3.6）](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/116e4008793d4c1ca42d152cf7dc226c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)
>
> 结合上图，一个完整的渲染流程如下：
>
> - 渲染进程解析 HTML 内容转换为能够读懂的 DOM 树结构，解析 CSS 为 CSSDOM
> - 把 DOM 和 CSSOM 结合起来生成渲染树(Render Tree)
> - 渲染树构建好了之后，将会执行布局过程，它将确定每个节点在屏幕上的确切坐标
> - 把渲染树展示到屏幕上。再下一步就是绘制，即遍历渲染树，并使用UI后端层绘制每个节点。
>
> 由浏览器的渲染流程图可知，DOM 解析和 CSS 解析是两个并行的进程，==所以 CSS 加载不会阻塞 DOM 树的解析==
>
> Render Tree是依赖于 DOM Tree 和 CSSOM Tree 的，所以无论 DOM Tree 是否已经完成，它都必须等待到 CSSOM Tree 构建完成，即 CSS 加载完成（或 CSS 加载失败）后，才能开始渲染。
>
> ==因此，CSS加载是会阻塞 DOM 树的渲染==

# 新版本v8引擎

> parser解析器
>
> > 生成AST抽象语法树
>
> interpreter解释器
>
> > v8引擎的解释器名为Ignition，生成byteCode字节码 ，并直接执行(byteCode字节码更加简洁，相当于25% - 50%的等效机器代码大小)
>
> > 清除AST 抽象语法树释放内存空间
>
> compiler编译器
>
> >  v8引擎的编译器名为TurboFan，代码运行过程中，解释器Ignition收集优化信息发送给编译器TurboFan
>
> > 编译出经过优化的机器代码
> >
> > 优化点：
> >
> > > 函数只声明==未调用==，不会被解析生成AST
> > >
> > > 函数只被调用一次，bytcode直接被解释执行(==因为需要解释器进行信息收集，这要求函数调用次数大于一==)
> > >
> > > 函数被调用多次，Igniton会收集函数类型信息，==可能==会被标记为热点函数，==可能==被编译成优化后的机器代码
> > >
> > > ![image-20220619162101821](images/image-20220619162101821.png)
>
> > 有些热点函数变更会由优化后的机器码还原成字节码，也就是deoptimization，回退字节码操作执行
> >
> > 例如:
> >
> > ```javascript
> > function sum(x,y){return x + y};
> > sum(1,2);
> > sum(3,4);
> > sum(5,6);
> > sum("7","8");//输入的xy的数据类型发生了改变，会回退字节码操作执行
> > ```
>
> > ![image-20220619160855345](images/image-20220619160855345.png)
>
> advantages:
>
> > 解决了旧版v8机器码占用大量内存的问题
> >
> > 在旧版v8基础上加入中间层字节码，可以方便实现一些优化策略
> >
> > 解决了旧版v8无法很好执行和优化JS新语法特性的问题
> >
> > ![image-20220619163052084](images/image-20220619163052084.png)
> >
> > 由于一开始不需要直接编译成机器码，生成了中间层的字节码，从而节约了时间
> >
> > 生成优化机器代码时，不需要从源码重新解析，直接通过字节码进行优化
> >
> > deoptimization回退操作也只需要回归中间层的字节码解释执行就可以了

# 预编译和重名优先级

> 在JavaScript中，当一般变量、函数、函数参数重名时，它们的[优先级](https://so.csdn.net/so/search?q=优先级&spm=1001.2101.3001.7020)为：
>
> 已初始化的变量声明 > 函数 > 函数参数 > 未初始化的变量声明
>
> 从预编译角度理解问题
>
> > 函数预编译(==覆盖原则==)
> >
> > > 创建AO对象，执行期上下文（后面更新关于执行期上下文详解）。
> > >
> > > 寻找函数的形参和var变量声明，将变量和形参名作为AO对象的属性名，值设定为undefined.(==最先预编译，所以未初始化的变量声明优先级最低==)
> > >
> > > 将形参和实参(==也就是外部传进的参数==)相统一，即更改形参后的undefined为具体的形参值。(==第二个预编译，所以函数参数优先级倒数第二低==)
> > >
> > > 寻找函数中的函数声明，将函数名作为AO属性名，值为函数体。(==倒数第二，所以函数声明优先级第二==)
> > >
> > > 最后开始逐行顺序执行代码(==执行了初始化赋值，所以初始化变量声明优先级最高，因为最后执行覆盖了前面的==)
> >
> > 全局预编译
> >
> > > 创建GO（Global Object，全局执行期上下文，在浏览器中为window）对象；
> > >
> > > 寻找var变量声明，并赋值为undefined；(==先预编译，所以优先级低于函数==)
> > >
> > > 寻找function函数声明，并赋值为函数体；(==后预编译，所以优先级高于函数==)
> > >
> > > 执行代码。
>

# 0.1+0.2 != 0.3

> 0.1+0.2 != 0.3
>
> > 根据语言规范，JavaScript 采用“遵循 IEEE 754 标准的双精度 64 位格式”（"double-precision 64-bit format IEEE 754 values"）表示数字。——在 JavaScript（除了[`BigInt`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt)）当中，**并不存在整数/整型 (Integer)。**
> >
> > ```
> > 0.1 + 0.2 = 0.30000000000000004
> > ```

# js数据类型以及数据类型判断方法以及栈内存和堆内存

> 简单数据类型/原始类型/基本数据类型
>
> > Number、String、Undefined、Null、Boolean、Symbol(es6新增)、Bigint(es10新增)
> >
> > Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。
> >
> > BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。
> >
> > undefined 代表的含义是**未定义**，null 代表的含义是**空对象**。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。
> >
> > 基本数据直接存储在栈(stack)中
>
> 复杂数据类型/引用数据类型
>
> > Object(包括Object、Array、Function、Date、RegExp)
> >
> > 引用数据存储的是该对象在==栈中的引用==，真实的数据存放在堆内存里
>
> 两种数据类型在存储位置上的不同
>
> > - 基本数据类型直接存储在==栈（stack）中==的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
> > - 引用数据类型存储在==堆（heap）中的对象，栈中的只是引用数据类型的指针==，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。
>
> 数据类型判断方法
>
> > typeof
> >
> > > ```js
> > > console.log(typeof 2);               // number
> > > console.log(typeof true);            // boolean
> > > console.log(typeof 'str');           // string
> > > console.log(typeof []);              // object    
> > > console.log(typeof function(){});    // function
> > > console.log(typeof {});              // object
> > > console.log(typeof undefined);       // undefined
> > > console.log(typeof null);            // object
> > > console.log(typeof NaN);             // number
> > > ```
> > >
> > > 数组、对象、null会判断成object，其余判断正确
> > >
> > > ==注意==
> > >
> > > ```js
> > > console.log(typeof 1);//number
> > > console.log(typeof 1 === Number);//false 难道是因为number是小写n Number是大写N？
> > > ```
> >
> > instanceof
> >
> > > ```js
> > > console.log(2 instanceof Number);                    // false
> > > console.log(true instanceof Boolean);                // false 
> > > console.log('str' instanceof String);                // false 
> > > 
> > > console.log([] instanceof Array);                    // true
> > > console.log(function(){} instanceof Function);       // true
> > > console.log({} instanceof Object);                   // true
> > > console.log(Function instanceof Object);             // true
> > > console.log(Object instanceof Function);             // true
> > > ```
> > >
> > > 可以看到，`instanceof`==只能正确判断引用数据类型==，而不能判断基本数据类型。且null和undefined直接报错
> >
> > constructor
> >
> > > ```js
> > > console.log((2).constructor === Number); // true
> > > console.log((true).constructor === Boolean); // true
> > > console.log(('str').constructor === String); // true
> > > console.log(([]).constructor === Array); // true
> > > console.log((function() {}).constructor === Function); // true
> > > console.log(({}).constructor === Object); // true
> > > ```
> > >
> > > null和undefined直接报错
> > >
> > > ==需要注意，如果创建一个对象来改变它的原型，`constructor`就不能用来判断数据类型了：==
> > >
> > > ```js
> > > function Fn(){};
> > >  
> > > Fn.prototype = new Array();
> > >  
> > > var f = new Fn();
> > > 
> > > console.log(Object.prototype.toString.call(f));/[object Object]
> > > console.log(f.constructor === Fn);//false
> > > console.log(f.constructor === Array);//true
> > > console.log(Array.isArray(f));//false
> > > ```
> > >
> > > ```js
> > > function Fn(){};
> > >  
> > > //Fn.prototype = new Array();
> > >  
> > > var f = new Fn();
> > > 
> > > console.log(Object.prototype.toString.call(f));/[object Object]
> > > console.log(f.constructor === Fn);//true
> > > console.log(f.constructor === Array);//false
> > > console.log(Array.isArray(f));//false
> > > ```
> >
> > Object.prototype.toString.call()
> >
> > > ```js
> > > var a = Object.prototype.toString;
> > >  
> > > console.log(a.call(2));
> > > console.log(a.call(true));
> > > console.log(a.call('str'));
> > > console.log(a.call([]));
> > > console.log(a.call(function(){}));
> > > console.log(a.call({}));
> > > console.log(a.call(undefined));
> > > console.log(a.call(null));
> > > ```

# 解构赋值

> 数组解构赋值
>
> > ```js
> > let list = [221,'Baker Street','London'];
> > let [houseNo,street] = list;
> > console.log(houseNo,street);// 221 , Baker Street
> > ```
> >
> > ```js
> > let list = [221,'Baker Street','London'];
> > let [houseNo,,city] = list;
> > console.log(houseNo,city);// 221 , London
> > ```
> >
> > ![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b538480af74fa4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)
> >
> > 默认值
> >
> > ```js
> > let list = [221,'Baker Street'];
> > let [houseNo,street,city = 'BJ'] = list;
> > console.log(houseNo,street,city);// 221 , Baker Street , BJ
> > ```
>
> 对象解构赋值
>
> > ```js
> > let details = {
> >     firstName:'Code',
> >     lastName:'Burst',
> >     age:22
> > }
> > const {firstName,age} = details;
> > // 相当于const {firstName: firstName, age: age} = details
> > console.log(firstName); // Code
> > console.log(age);       // 22
> > ```
> >
> > ```js
> > const person = {
> >   name: 'jsPool',
> >   country: 'China'
> > };
> > const {name:fullname,country:place} = person;
> > 
> > console.log(fullname); // jsPool
> > console.log(place); // China
> > ```
> >
> > 默认值
> >
> > ```js
> > const person = {
> >   name: 'jsPool',
> >   country: 'China'
> > };
> > let {age} = person;
> > console.log(age); // undefined
> > ```
> >
> > ```js
> > const person = {
> >   name: 'jsPool',
> >   country: 'China',
> >   sexual:undefined
> > };
> > let {age = 20,sexual:sex = 'male'} = person;
> > console.log(age); // 20
> > console.log(sex); // male
> > ```

# NaN相关

>  isNaN 和 Number.isNaN 函数的区别？
>
>  > - 函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。
>  > - 函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。
>
>  > ```js
>  > console.log(typeof NaN) // number
>  > console.log(NaN === NaN) // false
>  > console.log(Object.is(NaN, NaN)) // true
>  > ```

# 浅拷贝和深拷贝

> [浅谈基本数据类型，引用数据类型，浅拷贝与深拷贝_保护我方发量的博客-CSDN博客_引用数据类型深拷贝](https://blog.csdn.net/dgdfshsdf/article/details/123186779)
>
> [浅拷贝与深拷贝_star@星空的博客-CSDN博客](https://blog.csdn.net/weixin_43638968/article/details/103694753)
>
> [递归手写深拷贝_star@星空的博客-CSDN博客](https://blog.csdn.net/weixin_43638968/article/details/109243067)
>
> 
>
> ==浅拷贝和深拷贝只针对引用数据类型，基本数据类型只有赋值==
>
> 基本数据类型赋值之后互不干扰，引用数据类型赋值仅改变指针，前后互有干扰
>
> 浅拷贝**只进行一层拷贝**，深层次的引用类型还是共享内存地址，原对象和拷贝对象还是会互相影响。
>
> 深拷贝就是**无限层级拷贝**，深拷贝后的原对象不会和拷贝对象互相影响。
>
> 
>
> 浅拷贝(==对于数组的所有方法除了JSON.stringify和JSON.parse外，如果数组中的值为对象引用，则符合浅拷贝，如果数组中的值为字符串、数字和布尔值，则符合深拷贝==)(==这句话这样解释更好，浅拷贝只拷贝一层，对于字符串、数字和布尔值来说只可能有一层，而对象引用是多层的==)
>
> > > ```javascript
> > > let arr = [1, 3, {
> > >   username: ' kobe'
> > >   }];
> > > let arr3 = arr.slice();
> > > arr3[1] = 2
> > > arr3[2].username = 'sanwoo'
> > > console.log(arr,arr3);
> > > ```
> > >
> > > ![image-20220620134037772](images/image-20220620134037772.png)
> >
> > Object.assign
> >
> > > ```javascript
> > > var obj = { a: {a: "kobe", b: 39} };
> > >   var initalObj = Object.assign({}, obj);
> > >   initalObj.a.a = "wade";
> > > console.log(obj.a.a); //wade
> > > ```
> >
> > slice
> >
> > > ```js
> > > const fxArr = ["One", ['2'], "Three"]
> > > const fxArrs = fxArr.slice(0)
> > > fxArrs[0] = '1'
> > > fxArrs[1][0] = "love";
> > > console.log(fxArr) // ["One", ['love'], "Three"]
> > > console.log(fxArrs) // ["1", ['love'], "Three"]
> > > ```
> >
> > concat
> >
> > > ```js
> > > const fxArr = ["One", ['2'], "Three"]
> > > const fxArrs = fxArr.concat()
> > > fxArrs[0] = '1'
> > > fxArrs[1][0] = "love";
> > > console.log(fxArr) // ["One", ['love'], "Three"]
> > > console.log(fxArrs) // ["1", ['love'], "Three"]
> > > ```
> >
> > ...
> >
> > > ```javascript
> > > const obj1 = { a : 1, b : {c:1}}
> > > var k = {...obj1}
> > > obj1.b.c = 100000
> > > console.log(obj1 );//{a: 1,b: {c: 100000}}
> > > console.log(k);//{a: 1,b: {c: 100000}}
> > > ```
> >
>
> 深拷贝
>
> > 手写深拷贝用==Map==或者==weakMap==解决循环引用
> >
> > > Map的键值对都是目标对象，那么当有循环引用，递归调用时，添加一个条件判定Map中有没有这个key，有就直接返回这个key对应的value即可
> >
> > 先转换成字符串，在转换成(数组/对象) JSON.parse(JSON.stringify(XXXX))
> >
> > 此方法==缺点==
> >
> > > - 对于`undefined` `symbol` `函数`三种情况会直接忽略
> > > - 对象循环引用情况下会报错
> > > - 不能正确处理 new Date()
> > > - 不能处理正则
> >
> > > ```javascript
> > > var array = [
> > >     { number: 1 },
> > >     { number: 2 },
> > >     { number: 3 }
> > > ];
> > > var str = JSON.stringify(array);
> > > var copyArray = JSON.parse(str)
> > > copyArray[0].number = 100;
> > > console.log(array); //  [{number: 1}, { number: 2 }, { number: 3 }]
> > > console.log(copyArray); // [{number: 100}, { number: 2 }, { number: 3 }]
> > > ```
> >
> > 手写深拷贝(==最简版==)
> >
> > >```javascript
> > >function getObjectClass(obj) {
> > >   return Object.prototype.toString.call(obj).slice(8, -1)
> > >}
> > >
> > >function deepClone(obj) {
> > >   if(getObjectClass(obj) === 'Object'){
> > >      var res ={}
> > >   }else if(getObjectClass(obj) === 'Array'){
> > >      var res = []
> > >   }else {
> > >      return obj
> > >   }
> > >   for(let i in obj){
> > >      res[i] = deepClone(obj[i])
> > >   }
> > >   return res
> > >}
> > >// 简易版，不考虑es6的map、set、symbol，也不用考虑循环利用
> > >```
> > >
> > >第三方库`Lodash`中的`_.cloneDeep(value)`
> > >
> > >jQuery.extend

#  Object.is() 与比较操作符 =\==、== 的区别？

> - 使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。
> - 使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。
> - 使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。

# JavaScript的包装类型

> 在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：
>
> ```javascript
> const a = "abc";
> a.length; // 3
> a.toUpperCase(); // "ABC"
> ```
> 
>在访问`'abc'.length`时，JavaScript 将`'abc'`在后台转换成`String('abc')`，然后再访问其`length`属性。
> 
>JavaScript也可以使用`Object`函数显式地将基本类型转换为包装类型：
> 
>```javascript
> var a = 'abc'
> Object(a) // String {"abc"}
> ```
> 
> 也可以使用`valueOf`方法将包装类型倒转成基本类型：
>
> ```javascript
>var a = 'abc'
> var b = Object(a)
> var c = b.valueOf() // 'abc'
> ```
> 
> 看看如下代码会打印出什么：
> 
>```javascript
> var a = new Boolean( false );
>if (!a) {
> 	console.log( "Oops" ); // never runs
> }
> ```
> 
> 答案是什么都不会打印，因为虽然包裹的基本类型是`false`，但是`false`被包裹成包装类型后就成了对象，所以其非值为`false`，所以循环体中的内容不会运行。

# JavaScript的隐式转换

> 首先要介绍`ToPrimitive`方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：
>
> ```javascript
> /**
> * @obj 需要转换的对象
> * @type 期望的结果类型
> */
> ToPrimitive(obj,type)
> ```
>
> `type`的值为`number`或者`string`。
>
> **（1）当**`type`**为**`number`**时规则如下：**
>
> - 调用`obj`的`valueOf`方法，如果为原始值，则返回，否则下一步；
> - 调用`obj`的`toString`方法，后续同上；
> - 抛出`TypeError` 异常。
>
> **（2）当**`type`**为**`string`**时规则如下：**
>
> - 调用`obj`的`toString`方法，如果为原始值，则返回，否则下一步；
> - 调用`obj`的`valueOf`方法，后续同上；
> - 抛出`TypeError` 异常。
>
> 可以看出两者的主要区别在于调用`toString`和`valueOf`的先后顺序。默认情况下：
>
> - 如果对象为 Date 对象，则`type`默认为`string`；
> - 其他情况下，`type`默认为`number`。
>
> 总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：
>
> ```javascript
> var objToNumber = value => Number(value.valueOf().toString())
> objToNumber([]) === 0
> objToNumber({}) === NaN
> ```
>
> 而 JavaScript 中的隐式类型转换主要发生在`+、-、*、/`以及`==、>、<`这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用`ToPrimitive`转换成基本类型，再进行操作。
>
> 以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被`ToPrimitive`转换成基本类型，所以最终还是要应用基本类型转换规则）：
>
> `+`**操作符** `+`操作符的两边有至少一个`string`类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。
>
> ```javascript
> 1 + '23' // '123'
> 1 + false // 1 
> 1 + Symbol() // Uncaught TypeError: Cannot convert a Symbol value to a number
> '1' + false // '1false'
> false + true // 1
> ```
>
> `-`、`*`、`\`**操作符**
>
> `NaN`也是一个数字
>
> ```javascript
> 1 * '23' // 23
> 1 * false // 0
> 1 / 'aa' // NaN
> ```
>
> **对于**`==`**操作符**
>
> 操作符两边的值都尽量转成`number`：
>
> ```javascript
> 3 == true // false, 3 转为number为3，true转为number为1
> '0' == false //true, '0'转为number为0，false转为number为0
> '0' == 0 // '0'转为number为0
> ```
>
> **对于**`<`**和**`>`**比较符**
>
> 如果两边都是字符串，则比较字母表顺序：
>
> ```javascript
> 'ca' < 'bd' // false
> 'a' < 'b' // true
> ```
>
> 其他情况下，转换为数字再比较：
>
> ```javascript
> '12' < 13 // true
> false > -1 // true
> ```
>
> 以上说的是基本类型的隐式转换，而对象等引入数据类型会被`ToPrimitive`先调用内部的valueOf方法，如果调用完毕后还是引用数据类型，再使用toString方法转换为字符串基本数据类型：
>
> ```javascript
> var a = {}
> a > 2 // false
> ```
>
> 其对比过程如下：
>
> ```javascript
> a.valueOf() // {}, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步
> a.toString() // "[object Object]"，现在是一个字符串了
> Number(a.toString()) // NaN，根据上面 < 和 > 操作符的规则，要转换成数字
> NaN > 2 //false，得出比较结果
> ```
>
> 又比如：
>
> ```javascript
> var a = {name:'Jack'}
> var b = {age: 18}
> a + b // "[object Object][object Object]"
> ```
>
> 运算过程如下：
>
> ```javascript
> a.valueOf() // {}，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步
> a.toString() // "[object Object]"
> b.valueOf() // 同理
> b.toString() // "[object Object]"
> a + b // "[object Object][object Object]"
> ```

> 简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。
>
> 那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。

# 为什么会有**BigInt**的提案？

> JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。

# var let const和隐式声明

> 隐式声明
>
> > ```js
> > console.log(window.a)
> > // undefined
> > console.log(a)
> > // Uncaught ReferenceError: a is not defined
> > a = 3
> > // 不使用var let const的就是隐式声明，隐式声明会在预编译时在window上挂载一个属性a = undefined，但是没有变量提升所以不会创造全局变量a，所以console.log(a)会报错
> > ```
>
> 块作用域
>
> > 块作用域由{}包括，let和const由块作用域，var则是函数作用域(==所以var的变量会变成全局变量==)
> >
> > ```js
> > function b() {
> >  var a = 1
> > }
> > console.log(a);
> > // a is not defined 函数作用域
> > 
> > console.log(a);
> > if(0){
> > var a = 1
> > }
> > // undefined
> > // 因为var没有块作用域，且var变量提升
> > 
> > if(!('a' in window)){
> >  var a = 1
> > };
> > console.log(a)
> > // undefined
> > // var没有块作用域+变量提升，所以'a' in window是true
> > ```
> >
> > 块作用域解决了ES5中的两个问题：
> >
> > - 内层变量可能覆盖外层变量
> >
> >   ```js
> >   if(true) {
> >   var name = 'matt';
> >   console.log(name); // matt
> >   }
> >   console.log(name);  // matt
> >   ```
> >
> >   ```js
> >   if(true) {
> >   let name = 'matt';
> >   console.log(name); // matt
> >   }
> >   console.log(name);  // ReferenceError: name is not defined
> >   ```
> >
> > - 用来计数的循环变量泄露为全局变量
> >
> >   ```js
> >   for (var i = 0; i < 5; ++i ) {
> >   
> >   }
> >   console.log(i); // 5
> >   ```
> >
> >   ```js
> >   for (let i = 0; i < 5; ++i ) {
> >   
> >   }
> >   console.log(i); // ReferenceError: i is not defined
> >   ```
>
> 变量提升(==变量提升包括了给window添加属性==)和暂时性死区
>
> > var和函数声明存在变量提升，let和const没有变量提升(==因为暂时性死区的存在==)，即变量只能在声明后使用，而不能提前使用
> >
> > > 这里值得注意的是var a和var b虽然声明提升了，但仅仅是声明提升，后面的赋值初始化并不会提升，而是等到执行那一段代码才生效
> > >
> > > ```js
> > > console.log(window.a,a);
> > > // undefined undefined
> > > var a = 10;
> > > console.log(window.a,a);
> > > // 10 10
> > > 
> > > console.log(a,window.a);
> > > // ƒ a() {} ƒ a() {}
> > > function a() {}
> > > console.log(a,window.a);
> > >  // ƒ a() {} ƒ a() {}
> > >  ```
>
> 重复声明
>
> > var可以重复声明同一变量，let和const不可以，var let const混用对同一变量重复声明也会报错
>
> 给全局添加属性
>
> > var和函数声明会将该变量添加为全局对象的属性(==只有浏览器window会挂载，node的global下不会挂载这个属性==)，并且在赋值代码执行前是undefined
> >
> > let const不会给全局添加属性，但是输出是undefined
> >
> > ```js
> > var name = 'matt';
> > console.log(window.name); //matt
> > ```
> >
> > ```js
> > let name = 'matt';
> > console.log(window.name); // undefined
> > ```
>
> 初始值设置
>
> > 声明变量时var和let可以不设置初始值，而const则必须设置初始值
>
> 修改值
>
> > var和let可以修改值，const修改值会报错，但是如果变量是一个引用类型的数据，可以修改引用类型数据内部的值
> >
> > ```js
> > const person = {};
> > person.name = 'matt'; // matt
> > ```
> >
> > 因为const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。
>
> 
>
> > ==for循环执行逻辑: 先执行for里面的n次循环再执行n次块里面的语句==
> >
> > ==var: 在退出循环时，迭代变量保存的是导致最终退出循环的那一个值即5，所以在执行块里面的语句就会出现5个5==
> >
> > ==let: 用let声明迭代变量时，JavaScript引擎会在后台为每一次迭代循环声明一个新的迭代变量，每一个setTimeout引用的都是不同的新的迭代变量，所以console.log输出的是我们所期望的01234==
> > 
> > ```js
> > for (var i = 0; i < 5; ++i ) {
> > setTimeout(() => console.log(i), 0)
> > }
> > // 55555
> >```
> > 
> > ```js
> > for (let i = 0; i < 5; ++i ) {
> > setTimeout(() => console.log(i), 0)
> > }
> > // 01234
> > ```
> >
>

# 变量提升的好处

> - 提高性能
> - 容错性更好
>
> **（1）提高性能** 在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。
>
> 在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。
>
> **（2）容错性更好**
>
> 变量提升可以在一定程度上提高JS的容错性，看下面的代码：
>
> ```javascript
> a = 1;var a;console.log(a);
> 复制代码
> ```
>
> 如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。

# ES6 Module和CommonJS模块的区别：

> - CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const；
> - import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。
>
> ES6 Module和CommonJS模块的共同点：
>
> - CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。

# new操作符步骤

> new操作符的实现步骤如下：
>
> 1. 创建一个对象
> 2. 将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）
> 3. 指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）
> 4. 返回新的对象

# js静态作用域和动态作用域

> js是静态作用域，==函数初始化定义的位置就决定了函数的作用域，而不是函数被调用的位置决定函数的作用域==
>
> > ```js
> > var val = 1;
> > function test() {
> >     console.log(val);
> > }
> > function bar() {
> >     var val = 2;
> >     test();
> > }
> > 
> > bar();// 1
> > ```
> >
> > bar()中调用test()，test()定义在全局作用域下，它的函数作用域中没有val变量，那么向外查找也就是全局作用域找到val是1并返回
>
> ==定义在哪决定了它的作用域，即便被赋给了其他对象作为内部属性也不会改变作用域==
>
> > ```js
> > const a = {}
> > a.b = function(){
> >     console.log(this) // window而不是a对象
> > }
> > ```
>
> https://juejin.cn/post/7022537890114568205

# 作用域链

> 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。

# 执行上下文

> **简单来说执行上下文就是指：**
>
> 在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。
>
> 在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。
>
> - 全局上下文：变量定义，函数声明，this指向全局对象window
> - 函数上下文：变量定义，函数声明，`this`指向调用函数的那个对象，`arguments`

# js宏任务和微任务、事件循环、异步运行的机制

> script本身就算一个宏任务
>
> 执行顺序：
>
> 第一轮：宏任务(script)→同步任务→微任务→寻找下一个script然后循环
>
> 第二轮：宏任务(第一个script内的宏任务，例如setTimeout)→第一个script内的宏任务下的同步任务→第一个script内的宏任务下的微任务→宏任务(下一个script内的宏任务)
>
> ![image-20220611155532692](C:%5CUsers%5CHasee%5CDesktop%5C%E7%AC%94%E8%AE%B0%5Cimages%5Cimage-20220611155532692.png)
>
> 其中值得注意的是，==promise本身是同步任务==，.then() .catch() .finally()才是微任务
>
> [【JavaScript】《整体代码script》为何是一个宏任务_走馬勿观花的博客-CSDN博客_script是宏任务](https://blog.csdn.net/weixin_45389633/article/details/118737832)
>
> 
>
> ==process.nextTick是当前事件循环结束后，下一次事件循环开始前进行调用，是一个微任务，且永远比promise.then更快==
>
> > process.nextTick 永远大于 promise.then，原因其实很简单。。。在Node中，\_tickCallback在每一次执行完task queue中的一个任务后被调用，而这个_tickCallback中实质上干了两件事：
> >
> > 1.nextTickQueue中所有任务执行掉(长度最大1e4，Node版本v6.9.1)
> >
> > 2.第一步执行完后执行_runMicrotasks函数，执行microtask queue中的部分(promise.then注册的回调)
> >
> > 所以很明显 process.nextTick > promise.then
>
> 异步运行机制
>
> > 将同步任务按顺序压入执行栈stack，压入后被主线程立即执行(==因为主线程循环会不停的从执行栈中读取事件并执行==)然后弹出栈，当遇到异步任务时，将异步任务压入任务队列task queue，等到执行栈内清空了，再将任务队列task queue内的任务压入执行栈内并执行
>
> 事件循环event loop
>
> > 事件循环不停的查看执行栈是否清空了，清空了则将任务队列task queue内的任务压入执行栈，==异步任务分为宏任务和微任务==，==任务队列也分为(宏)任务队列task queue和微任务队列microtask queue==，事件循环会先压入宏任务再压入微任务(==一旦执行栈不为空则停止压入，所以压入宏任务后，宏任务执行后内部的同步任务被压入执行栈后微任务就停止压入，所以顺序是宏=>同=>微==)
> >
> > ```js
> > const promise = new Promise((resolve, reject) => {
> >     console.log(1);
> >     resolve()
> > }).then(() => {
> >     console.log('data');
> > })
> > setTimeout(() => {
> >         console.log('begin');
> >     }, 0);
> > console.log(4);
> > // 1 4 data begin
> > ```
> >
> > ```js
> > setTimeout(() => {
> >         console.log('begin');
> >     }, 0);
> > const promise = new Promise((resolve, reject) => {
> >     console.log(1);
> >     resolve()
> > }).then(() => {
> >     console.log('data');
> > })
> > console.log(4);
> > // 1 4 data begin
> > ```
> >
> > 上下对比可知是宏=>同=>微
>
> 整个流程
>
> > 所以整个流程是，一开始执行宏任务script压入task queue，此时执行栈为空，将script压入执行栈并执行然后弹出，script内部的任务按顺序压入执行栈，执行栈依次执行并弹出，碰到宏任务则压入(宏)任务队列task queue，碰到微任务则压入微任务队列microtask queue，待执行栈清空后压入微任务(==按照先宏后微的顺序，前面已经压入宏任务script了，现在轮到微任务了==)，微任务在执行栈内执行完弹出后再压入宏任务，以此循环
>
> ![cmd-markdown-logo](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/14/164974fa4b42e4af~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

# 类数组定义以及类数组转换成数组

> 一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。
>
> 常见的类数组转换为数组的方法有这样几种：
>
> > 通过 call 调用数组的 slice 方法来实现转换
> >
> > ```javascript
> > Array.prototype.slice.call(arguments);
> > //
> > [].slice.call(arguments)
> > ```
> >
> > 通过 call 调用数组的 splice 方法来实现转换
> >
> > ```javascript
> > Array.prototype.splice.call(arguments, 0);
> > ```
> >
> > 通过 apply 调用数组的 concat 方法来实现转换
> >
> > ```javascript
> > Array.prototype.concat.apply([], arguments);
> > ```
> >
> > 通过 Array.from 方法来实现转换
> >
> > ```js
> > Array.from(arguments);
> > ```
> >
> > ...扩展符
> >
> > ```js
> > [...arguments]
> > ```
> >
> > 手写
> >
> > ```js
> > var toArray = function(s){
> >     try{
> >         return Array.prototype.slice.call(s);
> >     } catch(e){
> >         var arr = [];
> >         for(var i = 0,len = s.length; i < len; i++){
> >             //arr.push(s[i]);
> >                arr[i] = s[i];  //据说这样比push快
> >         }
> >          return arr;
> >     }
> > }
> > ```

# this

> 默认情况下this指向==最后==调用这个方法的对象，也就是这个方法的父级执行上下文(==所处的上下文==)
>
> 默认绑定
>
> > ![image-20220620163033105](images/image-20220620163033105.png)
> >
> > - 第一种是**函数调用模式**，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象(==不管在哪个作用域==)。
> >
>
> 隐式绑定
>
> > ![image-20220620163104056](images/image-20220620163104056.png)
> >
> > console.log结果为'姓名：小红''身高：160厘米''体重：180斤'
> >
> > - 第二种是**方法调用模式**，如果一个函数作为一个对象的方法(属性)来调用时，this 指向这个对象。
> >
> > ![image-20220831162441473](images/image-20220831162441473.png)
> >
> > ![image-20220831162455169](images/image-20220831162455169.png)
> >
> > ==隐式丢失==
> >
> > > 如果是普通函数会隐式丢失，箭头函数不会(==因为不会被修改==)
> > >
> > > ```js
> > > function a() {
> > >     this.b = function () {
> > >         console.log(this);
> > >     }
> > >     this.c = () => {
> > >         console.log(this);
> > >     }
> > > }
> > > const d = new a()
> > > const e = d.b
> > > const f = d.c
> > > e()
> > > f()
> > > // window
> > > // a {b: ƒ, c: ƒ}
> > > ```
>
> 硬绑定(apply/call/bind)
>
> > ![image-20220620163158297](images/image-20220620163158297.png)
> >
> > console.log结果为'我的女朋友是小白'和'我的女朋友是小黄'
> >
> > 第四种是 **apply 、 call 和 bind 调用模式**，这三个方法都可以显示的指定调用函数的 this 指向。(==但箭头函数改变不了this==)
>
> 构造函数绑定
>
> > ![image-20220620163229993](images/image-20220620163229993.png)
> >
> > console.log结果为'我的老婆是小红'
> >
> > - 第三种是**构造器调用模式**，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象，箭头函数和普通函数作为方法的this都指向新创建对象(==且箭头函数的this指定后也不会被修改==)。
> >
> > ```js
> > function lover() {
> >     this.say = () => {
> >         console.log(this);
> >     }
> > }
> > const a = new lover()
> > a.say()
> > // lover { say: [Function (anonymous)] }
> > ```
>
> 这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。
>
> 箭头函数
>
> > 箭头函数的this始终指向其初始化位置的父级上下文(==所处的上下文==)的this，而不是指向父级上下文(==所处的上下文==)
> >
> > 并且不可以被apply、call、bind修改this指向
> >
> > ```javascript
> > let obj={name:'小明'}
> > var name='杨志' //不能用let声明，不存在变量提升
> > let pox={
> > name:'小红',
> > run:()=>{
> > console.log(this.name)//this
> > }
> > } 
> > // 对象方法中的this.指向方法的调用者。
> > pox.run();// 杨志
> > pox.run.call(obj)// 杨志
> > pox.run.apply(obj);// 杨志
> > pox.run.bind(obj)();//杨志
> > 
> > // 只有函数上下文和全局上下文，没有对象上下文，只要不在函数上下文的都在全局上下文，所以这里的箭头函数的父级上下文是全局上下文，全局上下文外没有上下文了，所以全局上下文的this指向window，所以箭头函数this指向window
> > // 只在浏览器环境下得出这样的结果，在node中箭头函数获取的全局对象是空对象{}，而不是真正的node全局对象
> > ```
>
> setTimeout
>
> > setTimeout中的函数为普通函数时，相当于==默认绑定，this指向window==，因为setTimeout触发的函数执行，不是由外部对象执行的，而是全局对象
> >
> > ![image-20220620165049106](images/image-20220620165049106.png)
> >
> > setTimeout中的函数为箭头函数时，this的指向和正常箭头函数一样(==下图中箭头函数的this指向wait()中的this，wait作为a对象的一个方法所以它的this指向a对象也就是{wait: f}==)
> >
> > ![image-20220907145132469](images/image-20220907145132469.png)
> >
> > ![image-20220907145321861](images/image-20220907145321861.png)
>
> ==自执行函数的this指向window/global==

# apply、call、bind

> 这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。
>
> apply的第一个参数是this绑定的对象，第二个参数是数组，数组内是其他需要传入的参数
>
> call的第一个参数是this绑定的对象，后面其余的参数是需要传入的参数
>
> bind的第一个参数是this绑定的对象，后面其余的参数是需要传入的参数，它返回一个新函数，需要手动调用，而apply和call则是直接调用

# js闭包

> 什么是闭包
>
> > 闭包是指有权访问另一个函数作用域中的变量的函数(也就是回调函数)，其本质是函数的作用域链中保存着外部函数变量对象的引用，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。(==因为闭包中的变量并不保存在栈内存中，而是保存在堆内存中，所以能访问函数内的变量==)
> >
> > 正常情况下读取不到函数内的局部变量，需要使用闭包。在js中只有函数内部的子函数才能读取局部变量，因此闭包可以简单理解成''定义在一个函数内部的函数''。
> 
> 闭包的应用场景
>
> > 1、函数作为参数被传递(回调函数)
>> 2、函数作为返回值被返回(回调函数)
> > 3、隐藏数据，封装对象的私有属性和方法
> >
> > > ```javascript
> > > function createCache() {
> > >     const num=100
> > >     const data = {} // 闭包中的数据，被隐藏，不被外界访问
> > >     return {
> > >         num:num,
> > >         set: function (key, val) {
> > >             data[key] = val
> > >         },
> > >         get: function (key) {
> > >             return data[key]
> > >         }
> > >     }
> > > }
> > > 
> > > const c = createCache()
> > > console.log(c.num)
> > > //num此时就作为c私有属性，c.num调用了c中的return中的num:num，然后再向外找到const num = 100，然后再返回100
> > > c.set('a', 100) 
> > > //set此时作为c的私有方法，c.set调用了c中的return中的set: function......，然后执行data[key] = val(这里可以访问data是因为这里set可以向外找到const data = {})
> > > console.log( c.get('a') )
> > > ```
> > >
> > > num是私有属性、set和get都是私有方法，都需要通过c.xxx的方式来调用，不能直接xxx来调用，这就是封装对象的私有属性和方法
> >
> > 函数防抖、函数节流
> > 单例模式

# 防抖和节流

> **所谓防抖，就是指触发事件后 n 秒后才执行函数，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。**
>
> ```JS
> function debounce(fn, delay = 200) {
>   let timer = 0
>   return function() {
>     // 如果这个函数已经被触发了
>     if(timer){
>       clearTimeout(timer)
>     }
>     timer = setTimeout(() => {
>       fn.apply(this, arguments); // 透传 this和参数
>       timer = 0
>     },delay)
>   }
> }
> ```
>
> **所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。** 节流会稀释函数的执行频率。
>
> ```JS
> // 节流函数
> function throttle(fn, delay = 200) {
>   let  timer = 0
>   return function () {
>     if(timer){
>       return
>     }
>     timer = setTimeout(() =>{
>       fn.apply(this, arguments); // 透传 this和参数
>       timer = 0
>     },delay)
>   }
> }
> ```

# 原型和原型链

> 在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，也就是原型(==下图中的Foo.prototype==)，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针(==也就是_proto\_==)(==_proto\_谷歌浏览器已经更新为[[prototype]]隐式原型==)，这个指针指向构造函数的 prototype 属性对应的值
>
> 每个构造函数都有.prototype属性，也就是原型
>
> 每个对象(==除了null==)都有自己的_proto\_隐式原型，该属性指向该对象的原型
>
> 每个prototype原型都有一个constructor属性，指回构造函数
>
> 如果prototype原型是另一个类型的实例呢，那就意味着这个原型本身有一个内部指针_proto\_指向另一个原型，相应的另一个原型也会有自己的\_proto\_指向另一个原型，这样就行成了一条原型链
>
> 获取对象属性时，如果对象本身没有这个属性，那就会去他的原型`__proto__`上去找，如果还查不到，就去找原型的原型，一直找到最顶层(`Object.prototype`)为止。Object.prototype对象也有`__proto__`属性值为null
>
> ![image-20220611165310471](C:%5CUsers%5CHasee%5CDesktop%5C%E7%AC%94%E8%AE%B0%5Cimages%5Cimage-20220611165310471.png)
>
> (==需要注意xxx.prototype本身是一个引用数据类型，如果两个实例的原型都是一个prototype，那么其中一个实例对它的prototype进行数据更改，另一个也会发生变化，浅拷贝==)

# 如何获得对象非原型链上的属性？

> 使用后`hasOwnProperty()`方法来判断属性是否属于原型链的属性：
>
> ```js
> function iterate(obj){
>    var res=[];
>    for(var key in obj){
>         if(obj.hasOwnProperty(key))
>            res.push(key+': '+obj[key]);
>    }
>    return res;
> } 
> ```

# for in和for of的区别

> for in取key下标，for of取value值
>
> 数组与字符串两者相似，都是分别遍历得到key下标和value值
>
> for of遍历普通对象报错，for of遍历普通对象需要配合Object.keys()一起使用
>
> [for···in和for···of的区别_star@星空的博客-CSDN博客](https://blog.csdn.net/weixin_43638968/article/details/109291957)

# map和Object的区别

> ![image-20220814223233949](images/image-20220814223233949.png)

# map和weakMap的区别

> map本质上就是键值对的集合，但是普通的Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。
>
> 实际上Map是一个数组，它的每一个数据也都是一个数组，其形式如下：
>
> ```javascript
> const map = [
>      ["name","张三"],
>      ["age",18],
> ]
> ```
>
> WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。**其键必须是对象**，原始数据类型不能作为key值，而值可以是任意的。一旦不再需要，WeakMap 里面的**键名对象和所对应的键值对会自动消失，不用手动删除引用**。而Map需要手动删除引用。

# 箭头函数和普通函数区别

> 声明方式不同
>
> > 普通函数用function，箭头函数小括号加箭头
>
> 匿名函数
>
> > 普通函数既可以匿名也可以具名，箭头函数只能匿名然后赋值给变量
>
> this指向
>
> > 普通函数this指向最后一次调用它的对象，箭头函数指向父级上下文的this
>
> 箭头函数的this永远不会改变，即使是call、apply、bind
>
> 箭头函数没有原型prototype
>
> 箭头函数没arguments，只有rest
>
> 箭头函数不能作为构造函数new
>
> 箭头函数的参数不能重名

# promise

> 终端promise链的==唯一方法==是==返回一个pending状态的promise对象==
>
> promise解决了什么问题
>
> > 解决了回调地狱，让代码结构性变好，代码可读性增强，更加直观
>
> promise的3种状态
>
> > 待定pending、兑现fulfilled/resolved、拒绝rejected
>
> resolve()
>
> > 传参时，将参数传入.then中作为形参
>
> reject()
>
> > 需要有.catch不然报错，传参时可以在.catch中接收到这个参数，不会主动打印
> >
> > ```js
> > new Promise((resolve, reject) => {
> >     reject('bad')
> > }).catch((res) => {
> >     console.log(1);
> > })
> > // 1
> > ```
> >
> > ```js
> > new Promise((resolve, reject) => {
> >     reject('bad')
> > }).catch((res) => {
> >     console.log(res);
> > })
> > // bad
> > ```
>
> .then
>
> > promise执行完毕后.then中的回调函数将被调起，then内有两个函数，第一个函数是promise变为接受状态时调用的函数，函数有一个参数是最终接受的结果，第二个函数是promise变为拒绝状态时调用的函数，函数有一个参数是被拒绝的原因
> >
> > 多个.then形成链式调用避免异步操作的代码层层嵌套。
> >
> > .then内的内容必须在前一个.then完成后才能被压入微任务队列，如果是第一个.then则需要等本体promise完成后再压入
>
> .catch
>
> > promise执行过程中出错，这个错误会以参数(通常写作Error)传入.catch，这样可以在.catch中捕获它
> >
> > 执行出错时catch生效而then不生效(因为执行出错promise没有执行完毕所以then不生效)
>
> .finally
>
> > 在promise链结束后调用，无论promise失败与否，这里一般做一些清理结尾工作
>
> promise.resolve()
>
> > 返回一个状态由给定 value 决定的 `Promise` 对象。如果该值是 thenable（即，带有 `then` 方法的对象），返回的Promise 对象的最终状态由 then 方法执行结果决定；否则，返回的 Promise 对象状态为已兑现，并且将该 value 传递给对应的 then 方法。
>
> promise.reject()
>
> > 返回一个状态为已拒绝的 `Promise` 对象，并将给定的失败信息传递给对应的处理函数。
>
> promise.all
>
> > Promise.all() 方法接收一个 promise 的 iterable 类型（注：Array，Map，Set 都属于 ES6 的 iterable 类型）的输入，并且只返回一个[`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)实例。
> >
> > 如果传入的是空可迭代对象，那么返回一个resolved状态promise
> >
> > 如果传入的参数不包含promise，返回一个异步完成asynchronously resolved的promise
> >
> > 其他情况返回一个pending的promise，如果所有的传入的promise都完成后返回的promise变为resolved并返回一个数组，数组内是所有promise成功返回的结果。如果传入的promise一旦出现一个promise失败，那么直接返回这个第一个失败的结果不管其他的promise
>
> promise.race
>
> > `race` 函数返回一个 `Promise`，它将与第一个传递的 promise 相同的完成方式被完成。它可以是完成（ resolves），也可以是失败（rejects），这要取决于第一个完成的方式是两个中的哪个。
> >
> > 如果传的迭代是空的，则返回的 promise 将永远等待。
> >
> > 如果迭代包含一个或多个非承诺值和/或已解决/拒绝的承诺，则 `Promise.race` 将解析为迭代中找到的第一个值。
>
> promise实现sleep
>
> ```js
> const sleep = (timer) => {
>   new Promise((resolve) => {
>    setTimeout(() => {
>       resolve('时间到')
>    }, timer);
>   }).then((res) => {
>     console.log(res);
>   })
> }
> 
>sleep(1000)
> ```

# async await

> async&await
>
> > async&await是对generator的封装，是一个语法糖，async将函数定义为异步函数，await只能在异步函数内生效，在 await 表达式之后的代码可以被认为是存在在链式调用的 then 回调中，多个 await 表达式都将加入链式调用的 then 回调中，返回值将作为最后一个 then 回调的返回值。
> >
> > await会返回promise微任务
>
> async&await的执行顺序
>
> > 同步执行直到await xxx执行完毕，执行完await xxx后直接将await后面的代码注册为微任务推入microtask queue(==此处注意如果xxx是个异步函数有返回值且await xxx被console.log，那么这个返回会先于await xxx后面的代码被注册为微任务==)，跳出async函数去按顺序执行外部的同步任务，然后推入异步任务，最后按照事件循环执行
> >
> > > xxx是异步函数且被console.log且返回值为await xxx，这种情况没搞清楚
> > >
> > > ![image-20220902222637366](images/image-20220902222637366.png)
>
> await 表达式的运算结果取决于它等的是什么。
>
> > - 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。
> > - 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。
>
> await使用时的陷阱
>
> > ![image-20220813150055369](images/image-20220813150055369.png)
> >
> > 虽然没有逻辑错误，但会打破这两个fetch的并行，等到第一个fetch执行完毕后再开始第二个fetch，更高效的方法是将这两个fetch用promise.all组合起来再await
> >
> > ![image-20220813150234813](images/image-20220813150234813.png)
>
> > ![image-20220813150304145](images/image-20220813150304145.png)
> >
> > 循环中执行异步操作不能调用forEach和map这类方法，尽管我们使用了await，但是forEach会立即返回，不会等到所有的异步操作执行完毕后再返回，如果我们希望所有的异步操作都一一执行完毕后再返回我们应该使用for循环
> >
> > ![image-20220813150545562](images/image-20220813150545562.png)
> >
> > 更进一步，想要循环中的所有操作都并发执行，可以使用for await，这里的for循环会等到所有的异步操作都完成后才继续向后执行
> >
> > ![image-20220813150725266](images/image-20220813150725266.png)
> >
> > 

# JavaScript异步编程的实现方式

> JavaScript中的异步机制可以分为以下几种：
>
> - **回调函数** 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。
> - **Promise** 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。
> - **generator** 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。
> - **async 函数** 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。

# JS继承

> 原型链继承
>
> > 继承的本质就是**复制，即重写原型对象，代之以一个新类型的实例**。
> >
> > 将原型重写为另一个构造函数new出来的实例，这样被重写原型的构造函数new出来的实例就可以继承另一个构造函数的原型的属性和方法
> >
> > 缺点：多个实例对引用数据类型的操作会被篡改(==因为是浅拷贝==)。
> >
> > ```js
> > function SuperType() {
> >     this.property = true;
> > }
> > 
> > SuperType.prototype.getSuperValue = function() {
> >     return this.property;
> > }
> > 
> > function SubType() {
> >     this.subproperty = false;
> > }
> > 
> > // 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype
> > SubType.prototype = new SuperType(); 
> > 
> > SubType.prototype.getSubValue = function() {
> >     return this.subproperty;
> > }
> > 
> > var instance = new SubType();
> > console.log(instance.getSuperValue()); // true
> > ```
>
> 借用构造函数继承
>
> > 核心代码是`SuperType.call(this)`，创建子类实例时调用`SuperType`构造函数，于是`SubType`的每个实例都会将SuperType中的属性复制一份。
> >
> > 缺点：只能继承父类实例的属性和方法，==不能继承原型的属性和方法==
> >
> > ```js
> > function  SuperType(){
> >     this.color=["red","green","blue"];
> > }
> > function  SubType(){
> >     //继承自SuperType
> >     SuperType.call(this);
> > }
> > var instance1 = new SubType();
> > instance1.color.push("black");
> > alert(instance1.color);//"red,green,blue,black"
> > 
> > var instance2 = new SubType();
> > alert(instance2.color);//"red,green,blue"
> > ```
>
> 组合继承
>
> > 组合上述两种方法就是组合继承。用原型链实现对**原型**属性和方法的继承，用借用构造函数技术来实现**实例**属性的继承。
> >
> > 缺点：
> >
> > 第一次调用`SuperType()`：给`SubType.prototype`写入两个属性name，color。
> >
> > 第二次调用`SuperType()`：给`instance1`写入两个属性name，color。
> >
> > ==实例对象`instance1`上的两个属性就屏蔽了其原型对象SubType.prototype的两个同名属性==。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。
> >
> > ```js
> > function SuperType(name){
> >   this.name = name;
> >   this.colors = ["red", "blue", "green"];
> > }
> > SuperType.prototype.sayName = function(){
> >   alert(this.name);
> > };
> > 
> > function SubType(name, age){
> >   // 继承属性
> >   // 第二次调用SuperType()
> >   SuperType.call(this, name);
> >   this.age = age;
> > }
> > 
> > // 继承方法
> > // 构建原型链
> > // 第一次调用SuperType()
> > SubType.prototype = new SuperType(); 
> > // 重写SubType.prototype的constructor属性，指向自己的构造函数SubType
> > SubType.prototype.constructor = SubType; 
> > SubType.prototype.sayAge = function(){
> >     alert(this.age);
> > };
> > 
> > var instance1 = new SubType("Nicholas", 29);
> > instance1.colors.push("black");
> > alert(instance1.colors); //"red,blue,green,black"
> > instance1.sayName(); //"Nicholas";
> > instance1.sayAge(); //29
> > 
> > var instance2 = new SubType("Greg", 27);
> > alert(instance2.colors); //"red,blue,green"
> > instance2.sayName(); //"Greg";
> > instance2.sayAge(); //27
> > ```
>
> 原型式继承
>
> > 用Object.create创建一个新对象，使用传入的对象来作为新创建对象的原型
> >
> > 缺点：原型式继承的多个实例的引用数据类型指向相同，存在篡改可能，且无法传递参数
> >
> > ```js
> > var person = {
> >   name: "Nicholas",
> >   friends: ["Shelby", "Court", "Van"]
> > };
> > 
> > var anotherPerson = Object.create(person);
> > anotherPerson.name = "Greg";
> > anotherPerson.friends.push("Rob");
> > 
> > var yetAnotherPerson = Object.create(person);
> > yetAnotherPerson.name = "Linda";
> > yetAnotherPerson.friends.push("Barbie");
> > 
> > alert(person.friends);   //"Shelby,Court,Van,Rob,Barbie"
> > ```
>
> 寄生式继承
>
> > 在原型式继承的基础上，创建新函数作为中间层，新函数内为返回的对象新增新的属性和方法
> >
> > 缺点同原型式继承
> >
> > ```js
> > function createAnother(original){
> >   var clone = Object.create(original); // 通过调用 object() 函数创建一个新对象
> >   clone.sayHi = function(){  // 以某种方式来增强对象
> >     alert("hi");
> >   };
> >   return clone; // 返回这个对象
> > }
> > var person = {
> >   name: "Nicholas",
> >   friends: ["Shelby", "Court", "Van"]
> > };
> > var anotherPerson = createAnother(person);
> > anotherPerson.sayHi(); //"hi"
> > ```
>
> ==寄生组合式继承==
>
> > 结合寄生式和组合式的继承方法，是目前最成熟的方法
> >
> > 这个例子的高效率体现在它只调用了一次`SuperType` 构造函数，并且因此避免了在`SubType.prototype` 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用`instanceof` 和`isPrototypeOf()`
> >
> > ```js
> > function inheritPrototype(subType, superType){
> >   var prototype = Object.create(superType.prototype); // 创建对象，创建父类原型的一个副本
> >   prototype.constructor = subType;                    // 增强对象，弥补因重写原型而失去的默认的constructor 属性
> >   subType.prototype = prototype;                      // 指定对象，将新创建的对象赋值给子类的原型
> > }
> > 
> > // 父类初始化实例属性和原型属性
> > function SuperType(name){
> >   this.name = name;
> >   this.colors = ["red", "blue", "green"];
> > }
> > SuperType.prototype.sayName = function(){
> >   alert(this.name);
> > };
> > 
> > // 借用构造函数传递增强子类实例属性（支持传参和避免篡改）
> > function SubType(name, age){
> >   SuperType.call(this, name);
> >   this.age = age;
> > }
> > 
> > // 将父类原型指向子类
> > inheritPrototype(SubType, SuperType);
> > 
> > // 新增子类原型属性
> > SubType.prototype.sayAge = function(){
> >   alert(this.age);
> > }
> > 
> > var instance1 = new SubType("xyc", 23);
> > var instance2 = new SubType("lxy", 23);
> > 
> > instance1.colors.push("2"); // ["red", "blue", "green", "2"]
> > instance1.colors.push("3"); // ["red", "blue", "green", "3"]
> > ```
>
> extend
>
> > 底层实现和寄生组合式相同

# js数组扁平化

> es6 flat
>
> > ```javascript
> > let arr1 = [1,2,['a','b',['中','文',[1,2,3,[11,21,31]]]],3];
> >  console.log( arr1.flat( Infinity ) ); 
> > ```
>
> reduce
>
> > ```javascript
> > const flat = (arr) => {
> >     return arr.reduce((pre, cur, curIndex, array) => {
> >        return Array.isArray(cur) ? pre.concat(flat(cur)) : pre.concat(cur)
> >     },[])
> > }
> > ```
>
> es6 ...
>
> > ```javascript
> > //ES6 增加了扩展运算符，用于取出参数对象的所有可遍历属性，拷贝到当前对象之中：
> > 
> > var arr = [1, [2, [3, 4]]];
> > console.log([].concat(...arr)); // [1, 2, [3, 4]]
> > //我们用这种方法只可以扁平一层，但是顺着这个方法一直思考，我们可以写出这样的方法：
> > 
> > // 改进
> > var arr = [1, [2, [3, 4]]];
> > 
> > function flatten(arr) {
> > 
> >     while (arr.some(item => Array.isArray(item))) {
> >         arr = [].concat(...arr);
> >     }
> > 
> >     return arr;
> > }
> > 
> > console.log(flatten(arr))
> > ```
>
> for循环递归
>
> > ```javascript
> > Array.prototype.flatten = function () {
> >   var resultArr = [];
> >   var len = this.length;
> >   for (var i = 0; i < len; i ++) {
> >     if (Array.isArray(this[i])) {
> >         resultArr = resultArr.concat(this[i].flatten());
> >     } else {
> >       resultArr.push(this[i]);
> >     }
> >   }
> >   return resultArr;
> > }
> > var arr=[1,2,3,[4,5,'hello',['world',9,666]]]
> > console.log(arr.flatten())//[1, 2, 3, 4, 5, "hello", "world", 9, 666]
> > ```
>
> yield
>
> > ```javascript
> > function* iterTree(tree){
> >       if(Array.isArray(tree)){
> >           for(let i = 0 ;i<tree.length;i++){
> >               yield* iterTree(tree[i]);
> >           }
> >       }else{
> >           yield tree;
> >       }
> >   }
> > 　let arr1 = [1, 2, ['a', 'b', ['中', '文', [1, 2, 3, [11, 21, 31]]]], 3];
> >   let list=[]
> > for (const x of iterTree(arr1)) {
> >     list.push(x)
> >   }
> >   console.log(list);//[1, 2, "a", "b", "中", "文", 1, 2, 3, 11, 21, 31, 3]
> > ```

# js数组去重

> es6 Set
>
> > ```javascript
> > var arr  = [1,1,'true','true',true,true,15,15,false,false, undefined,
> > undefined, null,null, NaN,NaN,'NaN', 0, 0, 'a', 'a',{},{}];
> >  
> > function arr_unique1(arr){
> > return  [...new Set(arr)];
> > //或者
> > //return  Array.from(new Set(arr));
> > }
> > arr_unique1(arr); // (13)[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}, {…}]
> > ```
>
> Map
>
> > ```javascript
> > function arr_unique2(arr) {
> >   let map = new Map();
> >   let array = new Array();  // 数组用于返回结果
> >   for (let i = 0; i < arr.length; i++) {
> >     if(map .has(arr[i])) {  // 如果有该key值
> >       map .set(arr[i], true);
> >     } else {
> >       map .set(arr[i], false);   // 如果没有该key值
> >       array .push(arr[i]);
> >     }
> >   }
> >   return array ;
> > }
> > 
> >  console.log(arr_unique2(arr)); //(13) [1, "a", "true", true, 15, false, 1, {…}, null, NaN, NaN, "NaN", 0, "a", {…}, undefined]
> > ```

# js数组排序和求和

> 升序
>
> > ```javascript
> > numbers.sort((a, b) => a - b);
> > console.log(numbers);
> > ```
> >
> > ```js
> > nums.sort((a, b) => Math.abs(a) - Math.abs(b))
> > // 绝对值升序
> > ```
>
> 降序
>
> > ```javascript
> > numbers.sort((a, b) => b - a);
> > console.log(numbers);
> > ```
> >
> > ```js
> > nums.sort((a, b) => Math.abs(b) - Math.abs(a))
> > // 绝对值降序
> > ```
>
> 求和(==for循环和for of除外==)
>
> > ```js
> > const sum = arr.reduce((a, b) => a + b)
> > // reduce求和
> > ```

# es5的类和es6的class的区别

> class类必须new调用
>
> class类不存在变量提升，es5中的类使用function定义的，存在变量提升
>
> class类无法遍历它实例原型链身上的属性和方法
>
> es6为new命令引入了一个new.target属性，它会返回new命令作用于的那个构造函数。如果不是通过new调用或Reflect.construct()调用的，new.target会返回undefined
>
> static静态方法只能通过类调用，不会出现在实例上；另外如果静态方法包含 this 关键字，这个 this 指的是类，而不是实例。static声明的静态属性和方法都可以被子类继承。
>
> 继承的区别
>
> > ```js
> > function Parent() {
> >     this.name = 'name';
> > }
> > Parent.prototype.say = function () {
> >     console.log('say something');
> > }
> > 
> > 
> > function Children() {
> >     Parent.call(this)
> > }
> > 
> > Children.prototype.__proto__ = Parent.prototype
> > Children.prototype.constructor = Children
> > // es5
> > ```
> >
> > ```js
> > class Person {
> >     constructor(name) { this.name = name }
> >     say() { console.log(this.name) }
> >   }
> >   
> > class Student extends Person { 
> >   }
> > 
> > const a = new Student('li')
> > // es6
> > ```

# 柯里化

> 柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。
>
> 柯里化（Currying）指将多元函数转化为多个一元函数连续定义。
>
> 柯里化（Currying）又称部分求值（Partial Evaluation），简单来说就是只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。

# MVVM和MVC

> MVC:
>
> > MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。
> >
> > 1. View 传送指令到 Controller
> > 2. Controller 完成业务逻辑后，要求 Model 改变状态
> > 3. Model 将新的数据发送到 View，用户得到反馈
> >    所有通信都是单向的。
> >
> > ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a65e1b9145894647a25788caf12ddd26~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)
>
> MVVM
>
> > MVVM 分为 Model、View、ViewModel：
> >
> > - Model代表数据模型，数据和业务逻辑都在Model层中定义；
> > - View代表UI视图，负责数据的展示；
> > - ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；
> >
> > Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系，而View和ViewModel之间又有数据绑定。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。
> >
> > 这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。
> >
> > ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5ce15b7b704483eb91ee1f5d1d64786~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

# 为何组件的data必须是一个函数(data为什么要return)

> 根实例对象data可以是对象也可以是函数（根实例是单例），不会产生数据污染情况
>
> 组件实例对象`data`必须为函数，目的是为了防止多个组件实例对象之间共用一个data，产生数据污染。采用函数的形式，initData时会将其作为构造函数都会返回全新data对象

# v-for为什么要添加唯一的key以及index不推荐作为key的原因

> 不绑定key，列表数据增删改查时，需要重新渲染整个列表
>
> 使用key可以在数据发生改变后，只渲染发生改变的数据，其他没有改变的直接复用(diff算法)
>
> 不推荐使用index作为key地原因是如果在数组中插入数据，那么这个数据及其后面的数据的index都发生变化，后面的数据其实没有改变但是却要重新渲染，造成无意义的性能开销

# v-if和v-show的区别

> v-if: 控制DOM元素的显示隐藏是将整个DOM元素添加或者收藏;
>
> v-show: 控制DOM 的显示隐藏是为DOM元素添加css的样式display，设置none或者是block，DOM元素依然存在
>
> ==v-if和v-show都会导致页面的重排和重绘，v-show只是改变dom的css，而v-if控制的是添加和删除dom，所以v-if在重绘重排前还进行了添加或删除dom元素的操作。==

# vue2和vue3生命周期

> vue2
>
> > beforeCreate created
> >
> > beforeMount Mounted
> >
> > beforeUpdate Updated
> >
> > beforeDestroy destroyed
> >
> > ![生命周期.webp](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ccd16fe2d1942e699bde7a7971c26a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)
>
> vue3
>
> > beforeCreate created
> >
> > beforeMount mounted
> >
> > beforeUpdate updated
> >
> > beforeUnmount unmounted
> >
> > <img src="images/2021060423231561.png" alt="img" style="zoom:40%;" />

# vue组件间通信方法

> 父=>子
>
> > props
> >
> > > `props`只能是父组件向子组件进行传值，`props`使得父子组件之间形成了一个单向下行绑定。子组件的数据会随着父组件不断更新。
> > >
> > > `props` 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。
> > >
> > > `props`属性名规则：若在`props`中使用驼峰形式，模板中需要使用短横线的形式
> > >
> > > ```js
> > > // 父组件
> > > <template>
> > >     <div id="father">
> > >         <son :msg="msgData" :fn="myFunction"></son>
> > >     </div>
> > > </template>
> > > 
> > > <script>
> > > import son from "./son.vue";
> > > export default {
> > >     name: father,
> > >     data() {
> > >         msgData: "父组件数据";
> > >     },
> > >     methods: {
> > >         myFunction() {
> > >             console.log("vue");
> > >         }
> > >     },
> > >     components: {
> > >         son
> > >     }
> > > };
> > > </script>
> > > ```
> > >
> > > ```js
> > > // 子组件
> > > <template>
> > >     <div id="son">
> > >         <p>{{msg}}</p>
> > >         <button @click="fn">按钮</button>
> > >     </div>
> > > </template>
> > > <script>
> > > export default {
> > >     name: "son",
> > >     props: ["msg", "fn"]
> > > };
> > > </script>
> > > ```
> >
> > provide/inject
> >
> > > ```js
> > > // 父组件
> > > provide() { 
> > >     return {     
> > >         num: this.num  
> > >     };
> > > }
> > > ```
> > >
> > > ```js
> > > // 子组件
> > > inject: ['num']
> > > ```
> >
>
> > $emit
> >
> > > $emit绑定一个自定义事件，当这个事件被执行的时就会将参数传递给父组件，而父组件通过`v-on`监听并接收参数。
> > >
> > > ```js
> > > // 父组件
> > > <template>
> > >   <div class="section">
> > >     <com-article :articles="articleList" @onEmitIndex="onEmitIndex"></com-article>
> > >     <p>{{currentIndex}}</p>
> > >   </div>
> > > </template>
> > > 
> > > <script>
> > > import comArticle from './test/article.vue'
> > > export default {
> > >   name: 'comArticle',
> > >   components: { comArticle },
> > >   data() {
> > >     return {
> > >       currentIndex: -1,
> > >       articleList: ['红楼梦', '西游记', '三国演义']
> > >     }
> > >   },
> > >   methods: {
> > >     onEmitIndex(idx) {
> > >       this.currentIndex = idx
> > >     }
> > >   }
> > > }
> > > </script>
> > > ```
> > >
> > > ```js
> > > //子组件
> > > <template>
> > >   <div>
> > >     <div v-for="(item, index) in articles" :key="index" @click="emitIndex(index)">{{item}}</div>
> > >   </div>
> > > </template>
> > > 
> > > <script>
> > > export default {
> > >   props: ['articles'],
> > >   methods: {
> > >     emitIndex(index) {
> > >       this.$emit('onEmitIndex', index) // 触发父组件的方法，并传递参数index
> > >     }
> > >   }
> > > }
> > > </script>
> > > ```
> >
> > ref / $refs
> >
> > > `ref`： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。
> > >
> > > ```js
> > > // 子组件
> > > export default {
> > >   data () {
> > >     return {
> > >       name: 'JavaScript'
> > >     }
> > >   },
> > >   methods: {
> > >     sayHello () {
> > >       console.log('hello')
> > >     }
> > >   }
> > > }
> > > ```
> > >
> > > ```js
> > > // 父组件
> > > <template>
> > >   <child ref="child"></component-a>
> > > </template>
> > > <script>
> > >   import child from './child.vue'
> > >   export default {
> > >     components: { child },
> > >     mounted () {
> > >       console.log(this.$refs.child.name);  // JavaScript
> > >       this.$refs.child.sayHello();  // hello
> > >     }
> > >   }
> > > </script>
> > > ```
> >
> > \$parent/\$child
> >
> > > 使用`$parent`可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）
> > >
> > > ```js
> > > <template>
> > >   <div>
> > >     <span>{{message}}</span>
> > >     <p>获取父组件的值为:  {{parentVal}}</p>
> > >   </div>
> > > </template>
> > > 
> > > <script>
> > > export default {
> > >   data() {
> > >     return {
> > >       message: 'Vue'
> > >     }
> > >   },
> > >   computed:{
> > >     parentVal(){
> > >       return this.$parent.msg;
> > >     }
> > >   }
> > > }
> > > </script>
> > > ```
> > >
> > > 使用`$children`可以让组件访问子组件的实例，但是，`$children`并不能保证顺序，并且访问的数据也不是响应式的。
> > >
> > > ```js
> > > // 父组件中
> > > <template>
> > >   <div class="hello_world">
> > >     <div>{{msg}}</div>
> > >     <child></child>
> > >     <button @click="change">点击改变子组件值</button>
> > >   </div>
> > > </template>
> > > 
> > > <script>
> > > import child from './child.vue'
> > > export default {
> > >   components: { child },
> > >   data() {
> > >     return {
> > >       msg: 'Welcome'
> > >     }
> > >   },
> > >   methods: {
> > >     change() {
> > >       // 获取到子组件
> > >       this.$children[0].message = 'JavaScript'
> > >     }
> > >   }
> > > }
> > > </script>
> > > ```
> >
> > \$attrs/\$listeners
> >
> > > 跨多级父子通信
>
> 兄弟间
>
> > eventBus
> >
> > 公共父组件
> >
> > > 兄弟组件childA通过$emit来触发公共父组件中的方法@，方法中则将emit传入的message再传给childB来实现兄弟间通信，childB通过props接收
> > >
> > > https://blog.csdn.net/u014508939/article/details/119675685
>
> 全能
>
> > vuex

# vue动态路由

> 

# vue2vue3区别

> options api和composition api的区别
>
> 响应式原理的不同
>
> diff算法的不同(双端对比和最长递增子序列)

# Object.defineProperty、proxy、reflect

> 先看掘金收藏再自己总结

# Vue3为什么用proxy、有什么优点好处/解决了什么问题、这些问题在vue2时期是怎么解决的

> 一次只能对一个属性进行监听，需要遍历来对所有属性监听。这个我们在上面已经解决了
>
> > vue2中遍历实现对所有属性监听
>
> 在遇到一个对象的属性还是一个对象的情况下，需要递归监听
>
> > vue2监听对象的属性还是对象时需要递归监听
>
> 对于对象的新增属性，需要手动监听
>
> > 需要使用 vm.$set 才能保证新增的属性也是响应式的。
>
> 对于数组通过push、unshift方法增加的元素，也无法监听
>
> > vue2中重写array原型解决

# proxy为什么一定要配合reflect使用(receiver避免代理陷阱)、proxy自身的局限性及解决方法(内部插槽、私有字段等)

> 先看掘金收藏再自己总结

# vue2 vue3 react diff

> vue2双端对比
>
> > oldStartIndex、oldEndIndex、newStartIndex和newEndIndex进行两两对比寻找复用节点，然后进行指针移动(==每次移动还要进行相应的节点移动变化==)直到中间相遇，当四次对比都**没找到**复用节点时，我们只能拿**新列表**的第一个节点去**旧列表**中找与其`key`相同的节点。在旧节点中找到了，那么在移动到对应位置，没找到那么直接在对应位置创建。删除多余节点
>
> vue3最长递增子序列
>
> > 处理相同的前置和后置元素的预处理
> >
> > 我们先根据**新列表**剩余的节点数量，创建一个`source`数组，并将数组填满`-1`。我们将**新节点**在**旧列表**的位置存储在该数组中，我们在根据`source`计算出它的`最长递增子序列`用于移动DOM节点。在找节点时要注意，**如果旧节点在新列表中没有的话，直接删除就好**。除此之外，我们还需要一个数量表示记录我们已经`patch`过的节点，如果数量已经与**新列表**剩余的节点数量一样，那么剩下的`旧节点`我们就直接删除了就可以了。观察这个重新赋值后的`source`，我们可以看出，如果是全新的节点的话，其在`source`数组中对应的值就是初始的`-1`，通过这一步我们可以区分出来哪个为全新的节点，哪个是可复用的。
> >
> > 我们从后向前进行遍历`source`每一项。此时会出现三种情况：
> >
> > 1. 当前的值为`-1`，这说明该节点是全新的节点，又由于我们是**从后向前**遍历，我们直接创建好DOM节点插入到队尾就可以了。
> > 2. 当前的索引为`最长递增子序列`中的值，也就是`i === seq[j]`，这说说明该节点不需要移动
> > 3. 当前的索引不是`最长递增子序列`中的值，那么说明该DOM节点需要移动，这里也很好理解，我们也是直接将DOM节点插入到队尾就可以了，因为队尾是排好序的。

# vue自定义指令

> 

# 单页面应用和多页面应用

> 单页面应用
>
> > 只有一张Web页面的应用，是一种从Web服务器加载的富客户端，单页面跳转仅刷新局部资源 ，公共资源(js、css等)仅需加载一次，常用于PC端官网、购物等网站
>
> 多页面应用
>
> > 多页面跳转刷新所有资源，每个公共资源(js、css等)需选择性重新加载，常用于 app 或 客户端等
>
> |                  | 单页面应用                                                   | 多页面应用                                   |      |      |      |
> | ---------------- | ------------------------------------------------------------ | :------------------------------------------- | ---- | ---- | ---- |
> | 组成             | 一个外壳页面加多个页面片段                                   | 多个完整页面构成                             |      |      |      |
> | 资源共用(css,js) | 只需在外壳加载一次                                           | 不共用，每次都需要加载                       |      |      |      |
> | 刷新方式         | 页面局部刷新或更改                                           | 整页刷新                                     |      |      |      |
> | url 模式         | a.com/#/pageone<br/>a.com/#/pagetwo                          | a.com/pageone.html<br/>a.com/pagetwo.html    |      |      |      |
> | 用户体验         | 页面片段间的切换快，用户体验良好                             | 页面切换加载缓慢，流畅度不够，用户体验比较差 |      |      |      |
> | 过渡动画         | vue提供transition封装组件，容易实现                          | 很难实现                                     |      |      |      |
> | 数据传递         | vuex等容易传递                                               | 需要cookie、localstorage、url参数等较难传递  |      |      |      |
> | SEO              | 需要单独方案、实现较为困难、不利于SEO检索 可利用服务器端渲染(SSR)优化 | 实现方法简易                                 |      |      |      |
> | 试用范围         | 高要求的体验度、追求界面流畅的应用                           | 适用于追求高度支持搜索引擎的应用             |      |      |      |
> | 开发成本         | 较高，常需借助专业的框架                                     | 较低 ，但页面重复代码多                      |      |      |      |
> | 维护成本         | 相对容易                                                     | 相对复杂                                     |      |      |      |

# vue router懒加载

> 非懒加载：
>
> ```javascript
> import List from '@/components/list.vue'
> const router = new VueRouter({
>   routes: [
>     { path: '/list', component: List }
>   ]
> })
> 复制代码
> ```
>
> （1）方案一(常用)：使用箭头函数+import动态加载
>
> ```javascript
> const List = () => import('@/components/list.vue')
> const router = new VueRouter({
>   routes: [
>     { path: '/list', component: List }
>   ]
> })
> 复制代码
> ```
>
> （2）方案二：使用箭头函数+require动态加载
>
> ```javascript
> const router = new Router({
>   routes: [
>    {
>      path: '/list',
>      component: resolve => require(['@/components/list'], resolve)
>    }
>   ]
> })
> 复制代码
> ```
>
> （3）方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。
>
> ```javascript
> // r就是resolve
> const List = r => require.ensure([], () => r(require('@/components/list')), 'list');
> // 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 
> const router = new Router({
>   routes: [
>   {
>     path: '/list',
>     component: List,
>     name: 'list'
>   }
>  ]
> }))
> ```

# vue router的hash和history模式

> 对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。
>
> hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。
>
> hash模式：
>
> > 地址中永远带着#号，不美观 。
> >
> > 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。
> >
> > 兼容性较好。
>
> history模式：
>
> > 地址干净，美观 。
> >
> > 兼容性和hash模式相比略差。
> >
> > 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。
> >
> > ```js
> > const router = new VueRouter({
> > mode: 'history',
> > routes: [...]
> > })
> > ```
>
> 在nodejs服务器端使用connect-history-fallback解决history模式404

# vue路由的生命周期流程

> 触发进入其它路由
>
> 调用要离开路由的组件守卫**beforeRouteLeave**
>
> 调用全局的前置守卫**beforeEach**
>
> 在重用的组件里调用 **beforeRouteUpdate**
>
> 在路由配置里调用 **beforeEnter**
>
> 解析异步路由组件
>
> 在将要进入的路由组件中调用**beforeRouteEnter**
>
> 调用全局的解析守卫**beforeResolve**
>
> 导航被确认
>
> 调用全局的后置钩子**afterEach**。
>
> 触发 DOM 更新**mounted**。
>
> 执行**beforeRouteEnter**守卫中传给 **next**的回调函数。
>
> ![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/12/16d2385e3732079d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

# 服务端渲染

> 服务端渲染有利于seo
>
> > 我们的爬虫爬取的其实是网页里的标签内容，通过获取这些内容进行分析。假设我们的网站都是采用前后端分离进行开发，界面都需要用js去请求接口，等到接口返回之后才展示真个界面。那么我们的爬虫也许根本获取不到我们想要的内容。
> >
> > 而通过服务渲染，服务端将整个界面的数据填充完整之后，直接返回这个界面。第一，少了客户端请求的过程。第二，返回的直接就是整个界面。必然使爬虫能够更快，更准确的爬取到它想要的信息。

# 图片懒加载

> 原理
>
> > 拿到所有的图片 demo 。
> >
> > 遍历每个图片判断当前图片是否到了可视区范围内。
> >
> > > 通过 `document.body.clientHeight` 获取可视区高度，再使用 `element.getBoundingClientRect()` API 直接得到元素相对浏览的 top 值， 遍历每个图片判断当前图片是否到了可视区范围内。代码如下
> > >
> > > ```js
> > > function lazyload() {
> > >   let viewHeight = document.body.clientHeight //获取可视区高度
> > >   let imgs = document.querySelectorAll('img[data-src]')
> > >   imgs.forEach((item, index) => {
> > >     if (item.dataset.src === '') return
> > > 
> > >     // 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置
> > >     let rect = item.getBoundingClientRect()
> > >     if (rect.bottom >= 0 && rect.top < viewHeight) {
> > >       item.src = item.dataset.src
> > >       item.removeAttribute('data-src')
> > >     }
> > >   })
> > > }
> > > ```
> >
> > 如果到了就设置图片的 src 属性。
> >
> > 绑定 window 的 `scroll` 事件，对其进行事件监听。==window.addEventListener('scroll', lazyload)==
> >
> > 在lazyload外套一个节流
> >
> > ```js
> > function throttle(fn, delay) {
> > let timer
> > let prevTime
> > return function (...args) {
> >  const currTime = Date.now()
> >  const context = this
> >  if (!prevTime) prevTime = currTime
> >  clearTimeout(timer)
> > 
> >  if (currTime - prevTime > delay) {
> >    prevTime = currTime
> >    fn.apply(context, args)
> >    clearTimeout(timer)
> >    return
> >  }
> > 
> >  timer = setTimeout(function () {
> >    prevTime = Date.now()
> >    timer = null
> >    fn.apply(context, args)
> >  }, delay)
> > }
> > }
> > window.addEventListener('scroll', throttle(lazyload, 200))
> > ```
>
> IntersectionObserver
>
> > `IntersectionObserver` 是浏览器原生提供的构造函数，接受两个参数：callback 是可见性变化时的回调函数，option 是配置对象（该参数可选）。
> >
> > 目标元素的可见性变化时，就会调用观察器的回调函数 callback。callback 一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。
> >
> > 
> >
> > callback 函数的参数`（entries）`是一个数组，每个成员都是一个 `IntersectionObserverEntry` 对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，`entries` 数组就会有两个成员。
> >
> > - time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒
> > - ==targe==t：被观察的目标元素，是一个 DOM 节点对象
> > - ==isIntersecting==: 目标是否可见
> > - rootBounds：根元素的矩形区域的信息，`getBoundingClientRect()`方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回 null
> > - boundingClientRect：目标元素的矩形区域的信息
> > - intersectionRect：目标元素与视口（或根元素）的交叉区域的信息
> > - intersectionRatio：目标元素的可见比例，即 `intersectionRect` 占 `boundingClientRect` 的比例，完全可见时为 1，完全不可见时小于等于 0
> >
> > ```js
> > const imgs = document.querySelectorAll('img[data-src]')
> > const config = {
> >   rootMargin: '0px',
> >   threshold: 0,
> > }
> > let observer = new IntersectionObserver((entries, self) => {
> >   entries.forEach((entry) => {
> >     if (entry.isIntersecting) {
> >       let img = entry.target
> >       let src = img.dataset.src
> >       if (src) {
> >         img.src = src
> >         img.removeAttribute('data-src')
> >       }
> >       // 解除观察
> >       self.unobserve(entry.target)
> >     }
> >   })
> > }, config)
> > 
> > imgs.forEach((image) => {
> >   observer.observe(image)
> > })
> > ```

# requestAnimationFrame

> `requestAnimationFrame` 方法只接收一个参数，即回调函数，意味着我们不用间隔。因为requestAnimationFrame 中的回调函数执行频率通常为 60 次每秒，但是它会随着屏幕刷新率的变化而变化。总之，回调函数的执行频率与浏览器的刷新次数相匹配。
>
> `requestAnimationFrame` 不会在后台一直执行，它会在页面出现的时候才会执行，比如 `document.hide` 为 `true` 的时候，而我们的定时器是一直会执行的。可以节省 `CPU` 和 `GPU` 等等。
>
> 可以避免丢帧，因为回调函数执行频率与浏览器刷新频率相匹配。
>
> ```js
> let box = document.getElementsByClassName('box')[0];
>     // 动画函数
> let num = 0;
> function animation() {
>   let res
>   if (num < 1000) {
>     num++;
>     box.style.left = num + 'px'
>     // 请求动画帧，即屏幕刷新的时候执行回调函数
>     res = requestAnimationFrame(animation); // 继续执行该函数
>   } else {
>     cancelAnimationFrame(res); // 清除该函数
>   }
> }
> let raID = requestAnimationFrame(animation);
> ```
>
> ![request_.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97ca77ceb2bb4342a3f762f558b70962~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

# scoped作用、原理、底层源码以及和css module的区别

> 作用
>
> > 当 style 标签加上 scoped 属性时，scoped 会在 DOM 结构及 css 样式上加上唯一性的标记 **data-v-xxx** 属性，从而达到样式私有化，不污染全局的作用；
>
> 原理
>
> > **Scope CSS 的本质是基于 HTML 和 CSS 属性选择器**，即分别给 HTML 标签和 CSS 选择器添加 data-v-xxx；
> >
> > 具体来说，它是 **通过 vue-loader 实现** 的，实现过程大致分 3 步：
> >
> > 1. 首先 vue-loader 会解析 .vue 组件，提取出 template、script、style 对应的代码块；
> > 2. 然后构造组件实例，在组件实例的选项上绑定 ScopedId；
> > 3. 最后对 style 的 CSS 代码进行编译转化，应用 ScopedId 生成选择器的属性；
>
> 源码
>
> 与css module区别
>
> > css module通过给样式名加hash字符串后缀的方式，实现特定作用域语境中的样式编译后的样式在全局唯一
> >
> > 

# plugins&loader

> 

# load和DOMContentLoaded

> DOMContentLoaded 事件在 **html文档加载完毕，并且 html 所引用的内联 js、以及外链 js 的同步代码都==执行完毕==后触发**。
>
> 当页面 DOM 结构中的 js、css、图片，以及 js 异步加载的 js、css 、图片都加载完成之后，才会触发 load 事件。

# 浏览器不同标签页之间的通信

> localStorage(==需要通信双方页面同源，即域名端口协议等都是相同的==)
>
> > ```js
> > // pageA.html
> > <body>
> >   <h1>pageA</h1>
> > </body>
> > <script>
> >   window.addEventListener("storage", (e) => {
> >     console.info("localStorage发生变化：", e)
> >   })
> > </script>
> > ```
> >
> > ```js
> > // pageB.html
> > <body>
> >   <h1>pageB</h1>
> >   <button id="btnB">添加数据到localStorage</button>
> > </body>
> > <script>
> >   let btnB = document.getElementById("btnB");
> >   let num = 0;
> >   btnB.addEventListener("click", () => {
> >     localStorage.setItem("num", num++)
> >   })
> > </script>
> > ```
>
> webSocket(==将服务器作为中介，pageA和pageB分别和服务器简历websocket链接，A更改了数据就向服务器发送消息，服务器再将消息发送给B，实现了标签页之间的通信==)
>
> > ```js
> > // index.js
> > let WebSocketServer = require("ws").Server;
> > let wss = new WebSocketServer({ port: 3000 });
> > 
> > 
> > // 创建保存所有已连接到服务器的客户端对象的数组
> > let clients = [];
> > 
> > 
> > // 为服务器添加connection事件监听，当有客户端连接到服务端时，立刻将客户端对象保存进数组中。
> > wss.on("connection", function (client) {
> >   console.log("一个客户端连接到服务器");
> >   if (clients.indexOf(client) === -1) {
> >     clients.push(client);
> >     // 接收客户端发送的消息
> >     client.on("message", function (msg) {
> >       console.log("收到消息:" + msg);
> >       // 将消息发送给非自己的客户端
> >       for (let key of clients) {
> >         if (key != client) {
> >           key.send(msg.toString());
> >         }
> >       }
> >     });
> >   }
> > });
> > ```
> >
> > ```js
> > // pageA
> > <script>
> >   // 创建一个websocket连接
> >   var ws = new WebSocket('ws://localhost:3000/');
> >   // WebSocket连接成功回调
> >   ws.onopen = function () {
> >     console.log("websocket连接成功")
> >   }
> >   // 这里接受服务器端发过来的消息
> >   ws.onmessage = function (e) {
> >     console.log("服务端发送的消息", e.data)
> >   }
> > </script>
> > ```
> >
> > ```js
> > <script>
> >   let btnB = document.getElementById("btnB");
> >   let num = 0;
> >   btnB.addEventListener("click", () => {
> >     ws.send(`客户端B发送的消息:${num++}`);
> >   })
> >   // 创建一个websocket连接
> >   var ws = new WebSocket('ws://localhost:3000/');
> >   // WebSocket连接成功回调
> >   ws.onopen = function () {
> >     console.log("websocket连接成功")
> >   }
> > </script>
> > ```
> >
> > 通常不会使用websocket方法，因为这会增加服务器的负担
>
> SharedWorker(==webworker的一种，需要同源，使用port发送和接收信息，原理和websocket类似==)
>
> > ```js
> > // worker.js
> > const set = new Set()
> > onconnect = event => {
> >   const port = event.ports[0]
> >   set.add(port)
> > 
> > 
> >   // 接收信息
> >   port.onmessage = e => {
> >     // 广播信息
> >     set.forEach(p => {
> >       p.postMessage(e.data)
> >     })
> >   }
> > 
> > 
> >   // 发送信息
> >   port.postMessage("worker广播信息")
> > }
> > ```
> >
> > ```js
> > <script>
> >   const worker = new SharedWorker('./worker.js')
> >   worker.port.onmessage = e => {
> >     console.info("pageA收到消息", e.data)
> >   }
> > </script>
> > ```
> >
> > ```js
> > <script>
> >   const worker = new SharedWorker('./worker.js')
> >   let btnB = document.getElementById("btnB");
> >   let num = 0;
> >   btnB.addEventListener("click", () => {
> >     worker.port.postMessage(`客户端B发送的消息:${num++}`)
> >   })
> > </script>
> > ```
> >
> > 这种方法调试不太方便，兼容性不太好
>
> 使用cookie+setInterval(==需要同源，有存储空间限制4k==)
>
> > ```js
> > <script>
> >   setInterval(() => {
> >     //加入定时器，让函数每一秒就调用一次，实现页面刷新
> >     console.log("cookie",document.cookie)
> >   }, 1000);
> > </script>
> > ```
> >
> > ```js
> > <script>
> >   let btnB = document.getElementById("btnB");
> >   let num = 0;
> >   btnB.addEventListener("click", () => {
> >     document.cookie = `客户端B发送的消息:${num++}`
> >   })
> > </script>
> > ```

# cookie的属性

> name: cookie的名称
>
> value: cookie的值
>
> domain: 指定了可以访问该cookie的web站点或者域
>
> path: 定义了Web站点上可以访问该Cookie的目录
>
> Expires/Max-Age: 设置Cookie的生存期。有两种存储类型的Cookie：会话性与持久性。Expires属性缺省时，为会话性Cookie，仅保存在客户端内存中，并在用户关闭浏览器时(==关闭浏览器不是关闭tab页面==)失效；持久性Cookie会保存在用户的硬盘中，直至生存期到或用户直接在网页中单击“注销”等按钮结束会话时才会失效
>
> size: cookie的大小
>
> secure: 设置是否通过https来发送cookie
>
> httponly: 用于防止客户端脚本通过document.cookie来访问cookie

# cookie localStorage sessionStorage

> cookie设计的初衷是用来和服务器通信，每次http请求header都携带cookie(即使不需要)
>
> cookie存储数据大小不超过4k、localStorage和sessionStorage则不超过5M
>
> cookie存储的数据在cookie设定的过期时间之前都有效，localStorage始终有效，即使页面浏览器被关闭，需要手动清除，sessionStorage只在当前页面关闭之前有效
>
> cookie和localStorage在所有同源窗口共享、sessionStorage只在当前窗口有效，即使是两个相同页面的不同窗口也不共享
>
> localStorage和sessionStorage支持时间通知机制，可以将更新的消息发送给监听者
>
> localStorage和sessionStorage的api使用更简便
>
> cookie有被劫持的风险，数据的不安全性

# http常见状态码

> 1xx：提示信息，表示请求正在处理
>
> 2xx：成功，表示请求正常处理完毕
>
> 3xx：重定向，表示请求需要更进一步的处理
>
> 4xx：客户端错误，表示语法错误或者请求无法实现
>
> 5xx：服务端错误，服务端处理请求出错
>
> > 200：请求成功
> >
> > 404：请求的资源没有找到
> >
> > 400：语义有误，服务端无法理解
> >
> > 401：当前额请求需要用户验证
> >
> > 403：服务端理解请求但拒绝执行
> >
> > 500：请求资源已找到，服务端发生了不可预期的错误
> >
> > 301：永久重定向
> >
> > 302：暂时重定向
> >
> > 304：not modified，未修改，还可以继续使用缓存
> >
> > https://juejin.cn/post/7030428038953173029

# http和https区别

> http是明文传输，https是http+ssl协议，https更加安全
>
> http默认端口为80，https则为443
>
> https多了加密过程，性能略低于http
>
> https需要ssl，增加了一定的费用
>
> > SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层：SSL记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL握手协议（SSL Handshake Protocol），它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。
>
> http和https可以互相访问
>
> > 重定向或者不设置强制https访问

# https页面中发起http请求

> [https的页面中可以发起http的请求吗 - 简书 (jianshu.com)](https://www.jianshu.com/p/141959b7ebad?ivk_sa=1024609w)
>
> 类似跨域的方法，运用img.src

# https工作原理

> 1、客户端先发送自己支持的加密协议以及版本信息,ssl,tls
>
> 2、服务器端选择合适的加密协议
>
> 3、服务器端返回客户端数字证书,证书内容：
>
> ```
>  证书的版本信息；
>  证书的序列号，每个证书都有一个唯一的证书序列号；
>  证书所使用的签名算法；
>  证书的发行机构名称，命名规则一般采用X.500格式；
>  证书的有效期，现在通用的证书一般采用UTC时间格式，它的计时范围为1950-2049；
>  证书所有人的名称，命名规则一般采用X.500格式；
>  证书所有人的公开密钥； // 服务器的公钥
>  证书发行者对证书的签名;
> ```
>
> 4、客户端接收证书后首先验证证书的合法性(使用签发机构的根证书验证),通过后生成一个随机数(对称秘钥)然后用从数字证书里拿到的服务器公钥对随机数加密传输发送到服务端。
>
> 5、服务器端接收到客户端发送的数据用私钥解密拿到随机数(通信用对称秘钥),然后用此随机数对要发送的数据加密
>
> 6、客户端接收到上一步服务端发来的数据后用第4步自己生成的随机数(对称秘钥)作为私钥解密数据
>
> 7、http的通信部分另作介绍,此刻ssl通信开始

# OSI七层模型、TCP/IP四层模型、五层模型

> >![image-20220621123941371](images/image-20220621123941371.png)
> >
> >应用层
> >
> >> 通过应用进程间的交互来完成特定网络应用，提供特定于应用程序的协议HTTP、FTP
> >>
> >> 应用层
> >>
> >> > 为应用程序提供服务
> >>
> >> 表示层
> >>
> >> > 数据格式转换、数据加密
> >>
> >> 会话层
> >>
> >> > 建立、管理和维护会话
> >
> >运输层
> >
> >> 负责向两台主机中进程之间的通信提供通用的数据传输服务(==两个进程分别用源端口和目标端口确定==)TCP UDP
> >>
> >> TCP
> >>
> >> > 提供面向连接的、可靠的数据传输服务，传输单位为报文段
> >>
> >> UDP
> >>
> >> > 提供无连接的、尽最大努力的数据传输服务，不保证数据传输的可靠性，传输单位为用户数据报
> >
> >网络层
> >
> >> 为分组交换网上的不同主机提供通信服务、使用IP选址和路由选择将数据包发送到特定的计算机
> >
> >数据链路层
> >
> >> 提供介质访问和链路管理，将二进制数据包与网络信号之间进行转换
> >
> >物理层
> >
> >> 传输单位为bit
>
> > 七层协议和五层协议的区别就是将应用层和表示层以及会话层合为应用层

# TCP三次握手、四次挥手

> ==发出去的ack确认序列号是上一个接收到的序列号seq+1，发出去的seq则是上一个接收到的ack确认序列号==
>
> ![image-20220621132723370](images/image-20220621132723370.png)
>
> > 客户端发送报文，SYN标志位置为1，序列号x
>
> > 服务端发回确认包，SYN和ACK标志位均为1，序列号为y，确认序列号是客户端的ISN+1即x+1
>
> > 客户端再次发送确认包，ACK标志位置为1，序列号为x+1，确认序列号为y+1
>
> 三次而不是两次握手的原因
>
> > 两次握手客户端有可能因为网络阻塞等原因发送多个请求报文，延迟到达后会与服务端建立多个连接，浪费资源
>
> ![image-20220621132742387](images/image-20220621132742387.png)
>
> 四次挥手的原因
>
> > TCP是全双工的通信机制，每个方向必须单独进行关闭。
> >
> > TCP传输连接关闭的原则如下：
> >
> > 当一端完成它的数据发送任务后就可以发送一个FIN字段置1的数据段来终止这个方向的数据发送；当另一端收到这个FIN数据段后，必须通知它的应用层 对端已经终止了那个方向的数据传送。
>
> > 客户端发送报文，包含FIN为1(finish)，序列号为u
>
> > 服务端接收后通知应用进程，返回确认包，包含ACK标志位置1，序列号为v，确认序列号u+1
>
> > 服务端发送报文，包含FIN为1，序列号为w，确认序列号u+1
>
> > 客户端接收后开启定时器市场为2MSL(==最大段报文生存时间==)
> >
> > 随后发送确认包，包含ACK标志位置1，序列号为u+1，确认序列号为w+1

# GET和POST的区别

> GET是不安全的，GET的数据被保存在请求的URL中(?和&)，POST数据保存在HTTP请求包体中，对用户来说不可见，相对安全
>
> GET请求一般会被缓存，POST则默认不缓存
>
> GET能传输的数据量小，受URL长度限制一般不大于2kb，POST一般认为数据量不受限制
>
> > 在这里我们要明确一点：HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。
>
> GET限制form表单数据集的值必须为ASCII码，POST没有限制
>
> GET执行效率更好
>
> > GET 产生一个 TCP 数据包
> >
> > > 1. 浏览器请求 TCP 连接（第一次握手）
> > > 2. 服务器答应进行 TCP 连接（第二次握手）
> > > 3. 浏览器确认，并发送 GET header和data（第三次握手，这个报文比较小，所以 HTTP 会在此时进行第一次数据发送）
> > > 4. 服务器返回 200 OK响应
> >
> > POST 产生两个 TCP 数据包
> >
> > > 浏览器请求 TCP 连接（第一次握手）
> > >
> > > 服务器答应进行 TCP 连接（第二次握手）
> > >
> > > 浏览器确认，并发送 POST 请求头（第三次握手，这个报文比较小，所以 HTTP 会在此时进行第一次数据发送）
> > >
> > > 服务器返回100 Continue响应
> > >
> > > 浏览器发送数据
> > >
> > > 服务器返回 200 OK响应
>
> GET是查询获取信息、POST是私密性的信息请求例如注册和登录

# 强缓存和协商缓存

> 浏览器加载资源时，首先根据请求头的expires和cache-control判断是否命中强缓存策略，命中则本地获取缓存资源，未命中则向远端服务器请求，验证是否命中协商缓存，命中则返回304，未命中则返回请求的缓存资源
>
> ==优先级Cache-Control > Expires > Etag > Last-modified==
>
> 强缓存
>
> > - Expires
> > - Cache-Control
> > - 强缓存都是由本地浏览器在确定是否使用缓存
>
> 协商缓存
>
> > - Etag、If-None-Match
> >
> > - Last-Modified、If-Modified-Since
> >
> > 
> >请求头发送If-None-Match，值为上一次的Etag，和这一次请求得到的Etag对比，相同则返回304，不同则返回缓存资源
> > 
> >请求头发送If-Modified-Since，值为上一次的Last-Modified，和这一次的Last-Modified对比，相同则返回304，不同则返回缓存资源

# 跨域

> 同源策略限制
>
> > 域名、协议、端口(==默认端口是80，可以省略==)相同
> >
> > 如果是非同源的，以下行为会受到限制：
> >
> > - `Cookie、LocalStorage`和`IndexDB`无法读取
> > - `DOM`无法获取
> > - `AJAX`请求不能发送
>
> 解决跨域问题
>
> > ==CORS==
> >
> > > CORS（Cross-origin resource sharing，跨域资源共享）是一个 W3C 标准，定义了在必须访问跨域资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。
> > >
> > > CORS可以发送任何类型的请求，但需要浏览器和服务器同时支持
> > >
> > > 整个`CORS`通讯过程中都是浏览器自动完成，不需要用户的参与。`CORS`通讯和同源的`AJAX`请求没有区别。浏览器一旦发现`AJAX`请求跨域，就会自动添加一些头部信息，有时候还会多出一次附加请求。
> > >
> > > 浏览器将`CORS`请求分为两类：简单请求和非简单请求。
> > >
> > > 只要同时满足一下两个条件就是简单请求，否则就是非简单请求：
> > >
> > > （1）请求方法是下列方法之一：
> > >
> > > - `HEAD`
> > > - `GET`
> > > - `POST`
> > >
> > > （2）`http`的头信息不超出以下几个字段：
> > >
> > > - `Accept`
> > > - `Accept-Language`
> > > - `Content-Language`
> > > - `Last-Event-ID`
> > > - `Content-Type`：只限于三个值`application/x-www-form-urlencoded、multipart/form-data、text/plain`
> > >
> > > 
> > >
> > > 简单请求浏览器会自动在头部信息里增加一个Origin字段，表示来自哪个源，服务器根据这个字段值判断值是否在请求范围内，在的话返回响应多出头信息字段Access-Control-Allow-Origin它的值要么是Origin的值，要么是*(==表示是公共资源==)，如果不在请求范围内则返回正常http回应，浏览器接收后没有发现Access-Control-Allow-Origin然后报错
> > >
> > > 
> > >
> > > 非简单请求浏览器在发送真正的请求之前，会先发送一个 Preflight 请求给服务器，这种请求使用 OPTIONS 方法，发送下列头部：
> > >
> > > - Origin：与简单的请求相同。
> > > - Access-Control-Request-Method: 请求自身使用的方法。
> > > - Access-Control-Request-Headers: （可选）自定义的头部信息，多个头部以逗号分隔。
> > >
> > > 例如：
> > >
> > > ```makefile
> > > Origin: http://www.laixiangran.cn
> > > Access-Control-Request-Method: POST
> > > Access-Control-Request-Headers: NCZ
> > > 复制代码
> > > ```
> > >
> > > 发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通：
> > >
> > > - Access-Control-Allow-Origin：与简单的请求相同。
> > > - Access-Control-Allow-Methods: 允许的方法，多个方法以逗号分隔。
> > > - Access-Control-Allow-Headers: 允许的头部，多个方法以逗号分隔。
> > > - Access-Control-Max-Age: 应该将这个 Preflight 请求缓存多长时间（以秒表示）。
> > >
> > > 例如：
> > >
> > > ```makefile
> > > Access-Control-Allow-Origin: http://www.laixiangran.cn
> > > Access-Control-Allow-Methods: GET, POST
> > > Access-Control-Allow-Headers: NCZ
> > > Access-Control-Max-Age: 1728000
> > > 复制代码
> > > ```
> > >
> > > 一旦服务器通过 Preflight 请求允许该请求之后，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样了。
> >
> > window.postMessage
> >
> > > 
> >
> > JSONP
> >
> > > 由于 `script` 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过动态创建 script 标签，然后利用 src 属性进行跨域，这也就是 JSONP 跨域的基本原理。
> > >
> > > #### 优点
> > >
> > > - 使用简便，没有兼容性问题，目前最流行的一种跨域方法。
> > >
> > > #### 缺点
> > >
> > > - 只支持 GET 请求。
> > > - 由于是从其它域中加载代码执行，因此如果其他域不安全，很可能会在响应中夹带一些恶意代码。
> > > - 要确定 JSONP 请求是否失败并不容易。虽然 HTML5 给 script 标签新增了一个 onerror 事件处理程序，但是存在兼容性问题。
> > >
> > > ```js
> > > function addScriptTag(src) {
> > >   var script = document.createElement('script');
> > >   script.setAttribute("type","text/javascript");
> > >   script.src = src;
> > >   document.body.appendChild(script);
> > > }
> > > // 定义回调函数
> > > function foo(data) {
> > >   console.log('Your public IP address is: ' + data.ip);
> > > };
> > > 
> > > window.onload = function () {
> > >   addScriptTag('http://example.com/ip?callback=foo');
> > > }
> > > ```
> > >
> > > 上面代码通过动态添加`<script>`元素，向服务器`example.com`发出请求。注意，该请求的查询字符串有一个`callback`参数，用来指定回调函数的名字，这对于`JSONP`是必需的。
> >
> > 图像ping跨域
> >
> > > 由于 `img` 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过 img 标签的 src 属性进行跨域，这也就是图像 Ping 跨域的基本原理。
> > >
> > > ```js
> > > var img = new Image();
> > > 
> > > // 通过 onload 及 onerror 事件可以知道响应是什么时候接收到的，但是不能获取响应文本
> > > img.onload = img.onerror = function() {
> > >     console.log("Done!");
> > > }
> > > 
> > > // 请求数据通过查询字符串形式发送
> > > img.src = 'http://www.laixiangran.cn/test?name=laixiangran';
> > > ```
> > >
> > > #### 优点
> > >
> > > - 用于实现跟踪用户点击页面或动态广告曝光次数有较大的优势。
> > >
> > > #### 缺点
> > >
> > > - 只支持 GET 请求。
> > > - 只能浏览器与服务器的单向通信，因为浏览器不能访问服务器的响应文本。
> >
> > 服务器代理
> >
> > > ==上线要用nginx跨域==
> > >
> > > 浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所有域的资源再返回给客户端。
> > >
> > > 服务器代理是万能的。
> > >
> > > ```js
> > > // vue 的开发服务器代理配置
> > > // vue.config.js
> > > module.exports = {
> > > devServer: { // 配置开发服务器
> > >  proxy: { // 配置代理
> > >    "/api": { // 若请求路径以 /api 开头
> > >      target: "http://dev.taobao.com", // 将其转发到 http://dev.taobao.com
> > >    },
> > >  },
> > > },
> > > };
> > > ```
> >
> > WebSocket
> >
> > > 即时双向通信，`WebScoket`使用`ws:\//`（非加密）和`wss:\//`（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。
> >
> > 片段标识符
> >
> > > 片段标识符指的是`URL`中`#`后面的内容，比如`http://sillywa.com/a.html#fragment`中的`#fragment`，如果只是改变片段标识符，页面不会重新刷新。
> > >
> > > 父窗口可以把信息写入子窗口的片段标识符：
> > >
> > > ```ini
> > > var src = originURL + '#' + data
> > > document.getElementById('myIframe').src = src
> > > 复制代码
> > > ```
> > >
> > > 子窗口通过监听`hashchange`事件得到通知：
> > >
> > > ```javascript
> > > window.onhashchange = function() {
> > >     console.log(window.location.hash)
> > > }
> > > ```
> >
> > document.domain
> >
> > window.name
> >
> > location.hash
> >

# 从输入url到页面渲染发生了什么

> 浏览器的地址栏内输入url并按下回车
>
> 浏览器查找当前URL是否存在缓存，并比较缓存是否过期
>
> DNS解析
>
> > 浏览器先查找自身的DNS缓存
> >
> > 查找操作系统的host文件
> >
> > 请求本地域名服务器
> >
> > 本地域名服务器请求根域名服务器
> >
> > 根域名服务器将顶级域名服务器的地址返回给本地域名服务器
> >
> > 本地域名服务器请求顶级域名服务器
> >
> > 顶级域名服务器将权限域名服务器的地址返回给本地域名服务器
> >
> > 本地域名服务器请求权限域名服务器，拿到对应DNS信息并返回
> >
> > ==以上过程并不是每次都完整的走一遍，在其中某一极得到了DNS信息就会直接返回，不会继续下一步==
>
> HTTP三次握手建立连接
>
> > 见上
>
> HTTP请求传输数据
>
> 服务器处理请求，浏览器接收HTTP响应
>
> 浏览器解析渲染
>
> > 解析html，构建dom树
> >
> > 解析css，生成css规则树
> >
> > 合并dom树和css规则树，生成render树
> >
> > 布局render树，计算各元素的大小和位置
> >
> > 绘制render树，浏览器将各层的信息发送给gpu，gpu合成各层信息显示在屏幕上

# 重排重绘

> ==重排开销>重绘开销==
>
> 页面生成的过程
>
> > 1.HTML 被 HTML 解析器解析成 DOM 树；
> >
> > 2.CSS  被 CSS 解析器解析成 CSSOM 树；
> >
> > 3.结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；
> >
> > 4.生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；
> >
> > 5.将布局绘制(paint)在屏幕上，显示出整个页面。
>
> > 重绘：某些元素的外观被改变，例如：元素的填充颜色
> >
> > 重排：重新生成布局，重新排列元素。
> >
> > 重绘不一定导致重排，重排一定导致重绘
>
> > 当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。
> >
> > 重排也叫回流，简单的说就是重新生成布局，重新排列元素。
> >
> > ![image-20220825221458143](images/image-20220825221458143.png)
>
> > 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。
> >
> > ![image-20220825225135794](images/image-20220825225135794.png)
>
> 优化减少重排重绘
>
> > 减小重排范围
> >
> > > 我们应该尽量以局部布局的形式组织html结构，尽可能小的影响重排的范围。
> > >
> > > - 尽可能在低层级的DOM节点上，如果你要改变p的样式，class就不要加在div上，通过父元素去影响子元素不好。
> > > - 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。
> >
> > 减少重排次数
> >
> > > 避免使用JS频繁改动样式，集中改变样式，直接统一在cssText中更改而不是逐个地去更改css，或者可以通过预先设置不同类名的样式方案，js修改class值来一次性改动样式
> > >
> > > > ```js
> > > > // bad
> > > > var left = 10;
> > > > var top = 10;
> > > > el.style.left = left + "px";
> > > > el.style.top = top + "px";
> > > > 
> > > > // 当top和left的值是动态计算而成时...
> > > > // better 
> > > > el.style.cssText += "; left: " + left + "px; top: " + top + "px;";
> > > > 
> > > > // better
> > > > el.className += " className";
> > > > ```
> > >
> > > 分离读写操作
> > >
> > > > ```js
> > > > // bad 强制刷新 触发四次重排+重绘
> > > > div.style.left = div.offsetLeft + 1 + 'px';
> > > > div.style.top = div.offsetTop + 1 + 'px';
> > > > div.style.right = div.offsetRight + 1 + 'px';
> > > > div.style.bottom = div.offsetBottom + 1 + 'px';
> > > > 
> > > > 
> > > > // good 缓存布局信息 相当于读写分离 触发一次重排+重绘
> > > > var curLeft = div.offsetLeft;
> > > > var curTop = div.offsetTop;
> > > > var curRight = div.offsetRight;
> > > > var curBottom = div.offsetBottom;
> > > > 
> > > > div.style.left = curLeft + 1 + 'px';
> > > > div.style.top = curTop + 1 + 'px';
> > > > div.style.right = curRight + 1 + 'px';
> > > > div.style.bottom = curBottom + 1 + 'px';
> > > > ```
> > > >
> > > > 原来的操作会导致四次重排，读写分离之后实际上只触发了一次重排，这都得益于浏览器的渲染队列机制：
> > > >
> > > > > 当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。
> > >
> > > 使用display: none
> > >
> > > > 一旦我们给元素设置 `display:none` 时（只有一次重排重绘），元素便不会再存在在渲染树中，相当于将其从页面上“拿掉”，我们之后的操作将不会触发重排和重绘，添加足够多的变更后，通过 `display`属性显示（另一次重排重绘）。通过这种方式即使大量变更也只触发两次重排。另外，`visibility : hidden` 的元素只对重绘有影响，不影响重排。
> > > 
> > > `DocumentFragment` 
> > > 
> > > > 避免频繁操作DOM，使用文档片段`DocumentFragment` 创建一个子树，创建完后一次性加入document
> > > 
> > > 使用 absolute 或 fixed 脱离文档流
> > > 
> > > > 使用绝对定位会使的该元素单独成为渲染树中 `body` 的一个子元素，重排开销比较小，不会对其它节点造成太多影响。当你在这些节点上放置这个元素时，一些其它在这个区域内的节点可能需要重绘，但是不需要重排。
> > > 
> > > 优化动画
> > >
> > > > 可以把动画效果应用到 ==`position`属性为 `absolute` 或 `fixed`== 的元素上，这样对其他元素影响较小。
> > >>
> > > > 动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量： 比如实现一个动画，以1个像素为单位移动这样最平滑，但是Layout就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多
> > >>
> > > > ==启用GPU加速==`GPU` 硬件加速是指应用 `GPU` 的图形性能对浏览器中的一些图形操作交给 `GPU` 来完成，因为 `GPU` 是专门为处理图形而设计，所以它在速度和能耗上更有效率。
> > >>
> > > > `GPU` 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL和视频(video)。

# XSS和CSRF

> Cross-Site Scripting（跨站脚本攻击），和css区分所以命名为xss
>
> XSS 可以分为==存储型==、==反射型==和==DOM 型==
>
> > - 存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。
> >
> > - 反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 
> >
> > - DOM 型指的通过修改页面的 DOM 节点形成的 XSS
>
> > **1）存储型 XSS 的攻击步骤：**
> >
> > 1. 攻击者将恶意代码提交到⽬标⽹站的数据库中。
> > 2. ⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
> > 3. ⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。
> > 4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。
> >
> > 这种攻击常⻅于带有⽤户保存数据的⽹站功能，如==论坛发帖、商品评论、⽤户私信==等。
> >
> > **2）反射型 XSS 的攻击步骤：**
> >
> > 1. 攻击者构造出特殊的 URL，其中包含恶意代码。
> > 2. ⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
> > 3. ⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。
> > 4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。
> >
> > 反射型 XSS 跟存储型 XSS 的区别是：==存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。==
> >
> > 反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如==⽹站搜索、跳转==等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。
> >
> > **3）DOM 型 XSS 的攻击步骤：**
> >
> > 1. 攻击者构造出特殊的 URL，其中包含恶意代码。
> > 2. ⽤户打开带有恶意代码的 URL。
> > 3. ⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。
> > 4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。
> >
> > DOM 型 XSS 跟前两种 XSS 的区别：==DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 是由服务端取出恶意代码，都是属于服务端的安全漏洞==。
>
> 预防xss措施
>
> > 输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。在防范 XSS 攻击时应避免此类方法。
> >
> > ==预防存储型和反射型XSS==
> >
> > > 使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。
> > >
> > > 对HTML做充分转义
> >
> > ==预防DOM型XSS==
> >
> > > 主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。
> >
> > 
> >
> > - 使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。
> >
> > > CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。
> > >
> > > 通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式
> >
> > 
> >
> > Http-only cookie
> >
> > > 禁止js读取敏感cookie，即使攻击者完成xss注入也无法窃取cookie
> >
> > 验证码
> >
> > > 预防脚本冒充用户提交危险操作
>
> CSRF
>
> > Cross-site request forgery跨站请求伪造
> >
> > GET类型的CSRF
> >
> > > ```js
> > >  <img src="http://bank.example/withdraw?amount=10000&for=hacker" > 
> > > ```
> > >
> > > 在受害者访问含有这个img的页面后，浏览器会自动向`http://bank.example/withdraw?account=xiaoming&amount=10000&for=hacker`发出一次HTTP请求。bank.example就会收到包含受害者登录信息的一次跨域请求。
> >
> > POST类型的CSRF
> >
> > > ```js
> > >  <form action="http://bank.example/withdraw" method=POST>
> > >     <input type="hidden" name="account" value="xiaoming" />
> > >     <input type="hidden" name="amount" value="10000" />
> > >     <input type="hidden" name="for" value="hacker" />
> > > </form>
> > > <script> document.forms[0].submit(); </script> 
> > > ```
> > >
> > > 访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。
> > >
> > > POST类型的攻击通常比GET要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，**后端接口不能将安全寄托在仅允许POST上面**。
> >
> > 链接类型的CSRF
> >
> > > ```js
> > >   <a href="http://test.com/csrf/withdraw.php?amount=1000&for=hacker" taget="_blank">
> > >   重磅消息！！
> > >   <a/>
> > > ```
> > >
> > > 需要用户在第三方网站内点击链接才生效，而前两种只需要打开第三方网站就可以发起攻击了
> >
> > 防御
> >
> > > 验证码
> > >
> > > Referer check；请求来源限制，此种方法成本最低，但是并不能保证 100% 有效，因为服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险。
> > >
> > > token；**token 验证的 CSRF 防御机制是公认最合适的方案。**(具体可以查看本系列前端鉴权中对token有详细描述)**若网站同时存在 XSS 漏洞的时候，这个方法也是空谈**
>
>  CSRF与 XSS 区别
>
> - **通常来说 CSRF 是由 XSS 实现的，CSRF 时常也被称为 XSRF（CSRF 实现的方式还可以是直接通过命令行发起请求等）。**
> - 本质上讲，XSS 是代码注入问题，**CSRF 是 HTTP 问题。** XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。**CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面(Token验证可以避免)。**

# 为什么利用多个域名来存储网站资源更有效

> cdn缓存更加方便
>
> 突破浏览器并发限制
>
> 节约cookie带宽
>
> 节约主域名的连接数、优化页面响应的速度
>
> 防止不必要的安全问题

# axios

> 

# WebSocket

> 

# babel

# 递归、尾递归、尾调用

> 尾调用
>
> > 当一个函数执行时的最后一个步骤是返回另一个函数的调用，这就叫做尾调用。
> >
> > ```js
> > function foo () { console.log(111); }
> > function bar () { foo(); }
> > function baz () { bar(); }
> > 
> > baz();
> > ```
> >
> > ![call stack](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/4/11/162b410edd7877e9~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)
> >
> > ```js
> > // 尾调用优化
> > function foo () { console.log(111); }
> > function bar () { return foo(); }
> > function baz () { return bar(); }
> > 
> > baz();
> > ```
> >
> > ![call stack](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/4/11/162b410edd6f2c82~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)
> >
> > ==尾调用是函数的最后一步操作，不需要保留外层函数的调用记录，直接用内层的调用记录替换外层的调用记录即可，栈中始终只有一条调用帧，可以节省很大一部分的内存空间==
>
> 递归
>
> > 函数调用自身
>
> 尾递归
>
> > 函数尾调用自身就是尾递归
> >
> > 相对于普通递归的优势和尾调用的优势相同，见上红字

# 如何写出高质量的css代码

> 清晰的css架构
>
> 规范的css命名格式
>
> 减少html和css的耦合度，避免html变动对css产生的影响
>
> 使用less、scss
>
> 规范的注释和间隔
>
> 单一职责原则，每个css只负责一个单一的责任
>
> 开闭原则，元素应该通过修饰符扩展，而不是直接在原有基础上修改
>
> 将重复的css代码抽象化
>
> 。。。

##### 笔试题&各类补充

> ```js
> <!DOCTYPE html>
> <html lang="en">
> <head>
>   <meta charset="UTF-8">
>   <meta http-equiv="X-UA-Compatible" content="IE=edge">
>   <meta name="viewport" content="width=device-width, initial-scale=1.0">
>   <title>Document</title>
>   <style>
>     #outer {
>         position: relative;
>         margin: auto;
>         width: 300px;
>         height: 300px;
>         background-color: #f00;
>     }
> 
>     #inner {
>         position: absolute;
>         top: 100px;
>         right: 100px;
>         left: 100px;
>         bottom: 100px;
>         background-color: #0f0;
>     }
>   </style>
> </head>
> <body>
>   <div id="outer">
>     <div id="inner">
>     </div>
>   </div>
>   <script>
>     const bindEvent = (div, tip) => {
>       div.addEventListener('mouseenter', () => console.log(`${tip} mouseenter`))
>       div.addEventListener('mouseleave', () => console.log(`${tip} mouseleave`))
>       div.addEventListener('mouseover', () => console.log(`${tip} mouseover`))
>       div.addEventListener('mouseout', () => console.log(`${tip} mouseout`))
>     }
>     bindEvent(outer, 'outer')
>     bindEvent(inner, 'inner')
>   </script>
> </body>
> </html>
> ```
>
> 鼠标从正中间从左往右划过
>
> ![image-20220814204551360](images/image-20220814204551360.png)

> ```js
> class ClassWithStaticMethod {
>   static staticMethod() {
>     return 'static method has been called.';
>   }
> }
> 
> console.log(ClassWithStaticMethod.staticMethod());
> // expected output: "static method has been called."
> 
> let a = new ClassWithStaticMethod();
> 
> a.staticMethod() // 报错
> ```
>
> static静态方法，不能通过类的实例调用，只能通过类本身调用

> ```js
> let arr = [{a: 1, b: 2}, {a: 1, b: 3}, 1]
> let newarr = arr.map(item => {
>     if(item.a && item.b){
>         item.a += 1
>         item.b += '1'
>     }else {
>         item += 1
>     }
>     return item
> })
> 
> console.log(arr === newarr);
> console.log(arr[0] === newarr[0]);// 对象是引用类型，所以虽然arr和newarr不全等，但是里面的对象通过map引用过去了
> console.log(arr[2] === newarr[2]);
> console.log(arr);
> console.log(newarr);
> ```
>
> ![image-20220814211243246](images/image-20220814211243246.png)

> 制作级联菜单功能时，调用的是下拉列表框的onChange事件

##### 手写

# proxy数据劫持(==访问属性时触发==)

> 实现console.log(obj.a ==\= 1 && obj.a =\== 2 && obj.a =\== 3)为true
>
> ```js
> let obj = new Proxy({a: 1}, {
> get(target, key, receiver) {
> return target.a++
> }
> })
> console.log(obj.a === 1 && obj.a === 2 && obj.a === 3);
> // true
> ```

# 实现add[1\][2\][3]+4 === 10

> ```js
> const source = {num: 0}
> const add = new Proxy(source,{
> get(target,key,receiver){
> if(key === Symbol.toPrimitive ){
> const temp = target.num
> target.num = 0
> // 重置
> return () => temp
> // 还不知道为什么一定要用函数
> }else{
> target.num += Number(key)
> return receiver
> //   返回proxy或者继承proxy的对象，因为这是一个链式调用
> }
> }
> })
> console.log(add[1][2][3] + 4 === 10);
> ```

# promise实现sleep

> ```js
> const sleep = (timer) => {
> return new Promise((resolve) => {
>   setTimeout(resolve('time out'), timer);
> })
> }
> sleep(5000).then((res) => console.log(res))
> ```

# 函数柯里化加重写toString

> ```js
>// 函数柯里化加重写toString
> const sum = (...rest) => {
>let args = [...rest];
> 	let fn = (...rest) => {
> 		args.push(...rest)
> return fn
> }
> fn.toString = () => {
> return args.reduce((x, y) => x + y)
> }
> return fn;
> }
>
> console.log(sum(2) == 2);
>console.log(sum(2, 3) == 5);
> console.log(sum(2, 3)(4) == 9);
> console.log(sum(2, 3)(3)(5) == 13);
> ```
> 

# Object.create

> ```js
> function craete(obj) {
>     function F() {}
>     F.prototype = obj
>     return new F()
> }
> ```

# instanceof

> ```js
> function myInstanceOf(left, right) {
>     let proto = Object.getPrototypeOf(left)
>     let prototype = right.prototype
>     while(1){
>         if(!proto) return false
>         if(proto === prototype) return true
>         proto = Object.getPrototypeOf(proto)
>     }
> }
> // 因为使用的是Object.getPrototypeOf，所以比原生的instanceof范围更广，可以判断基本数据类型了
> ```

# new

> ```js
> function myNew() {
>   let newObject = null;
>   let constructor = Array.prototype.shift.call(arguments);
>   // 将构造函数shift出来
>   let result = null;
>   // 判断参数是否是一个函数
>   if (typeof constructor !== "function") {
>     console.error("type error");
>     return;
>   }
>   // 新建一个空对象，对象的原型为构造函数的 prototype 对象
>   newObject = Object.create(constructor.prototype);
>   // 将 this 指向新建对象，并执行函数
>   result = constructor.apply(newObject, arguments);
>   // 判断返回对象
>   let flag = result && (typeof result === "object" || typeof result === "function");
>   // 判断返回结果
>   return flag ? result : newObject;
> }
> // 使用方法
> myNew(构造函数, 初始化参数);
> ```

防抖

> ```js
> function debounce(fn, delay = 200) {
>             let timer = 0
>             return function () {
>                 let context = this
>                 let args = [...arguments]
>                 if (timer) clearTimeout(timer)
>                 timer = setTimeout(() => {
>                     fn.apply(context, args)
>                 }, delay);
>             }
>         }
> // 非立即执行版本 在触发事件后函数 n 秒后才执行，而如果我在触发事件后的 n 秒内又触发了事件，则会重新计算函数执行时间。
> 
> function debounce(fn, delay = 200) {
>             let timer = 0
>             return function () {
>                 let context = this
>                 let args = [...arguments]
>                 if (timer) clearTimeout(timer)
>                 const callNow = !timer
>                 timer = setTimeout(() => {
>                     timer = 0
>                 }, delay);
>                 if(callNow) fn.apply(context, args)
>             }
>         }
> // 立即执行版本，触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。
> ```

节流

> ```js
> function throttle(fn, delay = 1000) {
>             let timer = 0
>             return function () {
>                 let context = this
>                 let args = arguments
>                 if(timer) return
>                 timer = setTimeout(() => {
>                     fn.apply(context, args)
>                     timer = 0
>                 }, delay);
>             }
>         }
> // 非立即执行版，停止触发后会再执行一次
> 
> function throttle(fn, delay = 1000) {
>             let pre = 0
>             return function () {
>                 let now = Date.now()
>                 let context = this
>                 let args = arguments
>                 if(now - pre > delay){
>                     fn.apply(context, args)
>                     pre = now
>                 }
>             }
>         }
> // 时间戳立即执行版本
> 
> function throttle(fn, delay = 1000) {
>             let timer = 0, pre = 0
>             return function () {
>                 let context = this
>                 let args = [...arguments]
>                 let now = Date.now()
>                 let remaining = delay - (now - pre)
>                 if(remaining <= 0 || remaining > delay){
>                     if(timer) {
>                         clearTimeout(timer)
>                         timer = 0
>                     }
>                     pre = now
>                     fn.apply(context, args)
>                 }else if(!timer){
>                     timer = setTimeout(() => {
>                         pre = Date.now()
>                         timer = 0
>                         fn.apply(context, args)
>                     }, remaining);
>                 }
>             }
>         }
> // 上面两种的结合，会在开始前和结束后都执行一次
> ```

##### 输出题

> promise
>
> > ```js
> > new Promise((resolve, reject) => {
> >  console.log(1);
> >  resolve()
> > }).then((a) => {
> >  console.log(2);
> >  new Promise((resolve, reject) => {
> >      console.log(3);
> >      resolve()
> >  }).then((b) => {
> >      console.log(4);
> >  }).then((c) => {
> >      console.log(5);
> >  })
> > }).then((d) => {
> >  console.log(6);
> > })
> > // 1 2 3 4 6 5
> > ```
> >
> > 根据promise的规范，同级的.then之间需要在前一个.then的promise执行完毕后后一个.then才被推进微任务队列，而第一个.then则是在主体promise完成后推入微任务队列(==所以两个new promise内都有resolve()就是为了让new的promise执行完毕==)
> >
> > 先打印1，将a回调放入微任务队列，再打印2，再打印3，resolve后将b回调放入微任务队列，此时a回调完成，将d回调放入微任务队列，微任务队列中b在d前面，先进先出，先执行b回调，打印4，b回调完成将c回调放入微任务队列，此时微任务队列中d回调在c回调前面，执行d回调，打印6，最后执行c回调，打印5
>
> 
>
> ![image-20220616204911169](images/image-20220616204911169.png)
>
> 
>
> ![image-20220616205147479](images/image-20220616205147479.png)
>
> 
>
> ```js
> let obj = {
> num: 5,
> func: function () {
>   let that = this;
>   that.num *= 2;
>   (function () {
>       this.num *= 3;
>       console.log(this);
>       that.num *= 4;
>       return function () {
>           this.num *= 5;
>           that.num *= 6;
>           // 这里return的function不会执行而是作为返回值返回，这里没有变量来接
>       }
>   })()
> }
> }
> var num = 2;
> obj.func();
> console.log(num);
> console.log(obj.num);
> //浏览器下 window 6 40
> //node下 global 2 40 因为node下var不会把变量挂载到global身上
> ```
>
> ```js
> function a(){
>     var arr = []
>     for(var i = 1; i <= 9; i++){
>         arr.push(function () {
>             return i*i*i*i
>         })
>     }
>     console.log(i)
>     return arr
> }
> 
> var r = a()
> var f1 = r[7]
> var f2 = r[6]
> var f3 = r[5]
> var f4 = r[4]
> console.log(f1(), f2(), f3(), f4());
> // 10
> // 10000 10000 10000 10000
> // var泄露
> ```

> https://blog.csdn.net/qq_35721888/article/details/106647403
>
> ```js
> console.log(a);
> if(false){
> var a = 1;
> }
> // undefined
> // var没有块作用域+变量提升
> ```
>
> ```js
> var a = 1;
> if(true){
> console.log(a);
> let a = 2;
> }
> // ReferenceError: Cannot access 'a' before initialization
> ```
>
> ```js
> var a = {n: 1}
> var b = a
> a.x = a = {n: 2}
> 
> console.log(a.n, b.n);
> console.log(a.x, b.x);
> // 2 1 
> // undefined {n: 2}
> // .运算符比 = 先运行
> 
> var a = {x:2,y:3};
> var b = a; 
> a.x = a = {n:1};
> console.log(a,b)
> // { n: 1 } { x: { n: 1 }, y: 3 }
> ```
>
> ```js
> console.log(c);
> var c;
> function c(a) {
> console.log(a);
> var a = 3;
> function a(){
> }
> }
> c(2);
> // function c function a
> // 变量提升也有优先级, 函数声明 > arguments > 变量声明
> ```
>
> ```js
> var c = 1
> function c(c) {
> console.log(c);
> var c = 3;
> }
> console.log(c);
> c(2);
> // 1 c is not a function
> // 已初始化的变量声明优先级>函数
> ```
>
> ```js
> var name = 'erdong';
> (function () {
> 
> if (typeof name === 'undefined') {
> name = 'chen'
> console.log(name)
> } else {
> console.log(name)
> }
> })();
> // erdong
> 
> var name = 'erdong';
> (function () {
> var name;
> if (typeof name === 'undefined') {
> name = 'chen'
> console.log(name)
> } else {
> console.log(name)
> }
> })();
> // chen
> ```
>
> ```js
> if(!('a' in window)){
> var a = 1
> };
> console.log(a)
> // undefined
> // var没有块作用域+变量提升，所以'a' in window是true
> 
> var a;
> if (!(a in window)) {
> a = 1;
> }
> console.log(a);
> // 同等上面代码
> ```
>
> ```js
> let res = ['1', '2', '100'].map(parseInt)
> console.log(res)
> // 1 NaN 4
> // map会给函数传入三个参数the element、the index、the array，parseInt只接受两个，所以这里相当于parseInt('1', 0) parseInt('2', 1) parseInt('100', 2)
> ```
>
> ```js
> async function async1() {
> console.log(1);
> await async2()
> console.log(2);
> }
> 
> async function async2() {
> console.log(3);
> }
> 
> console.log(4);
> 
> setTimeout(function () {
> console.log(5);
> }, 0);
> 
> async1()
> 
> new Promise(function(resolve) {
> console.log(6);
> resolve()
> }).then(function() {
> console.log(7);
> })
> // 4 1 3 6 2 7 5
> ```
>
> ```js
> var boss = 'bill'
> var working = {
> boss: 'bob',
> ask(){
> console.log(this.boss);
> },
> askagain(){
> setTimeout(function() {
> console.log(this);
> }, 100);
> },
> askkeep(){
> setTimeout(() => {
> console.log(this);
> }, 100);
> }
> }
> working.ask()
> working.askagain()
> working.askkeep()
> // bob
> // window
> // {boss: 'bob', ask: ƒ, askagain: ƒ, askkeep: ƒ}
> ```
>
> ```js
> var val = 10
> function root() {
> function child() {
> this.val--
> console.log(this.val);
> return child
> }
> return {val: 20, fn: child}
> }
> root().fn()()
> // 19 9
> // root()后返回{val: 20, fn: child}，然后{val: 20, fn: child}.fn()则执行child函数，需要注意的是这里的child函数是{val: 20, fn: child}的一个属性，所以它的this指向这个对象{val: 20, fn: child}，所以this.val = 20然后--console.log出来19，然后返回child函数，再执行child函数时这个child函数就不是某个对象的属性值了，所以this指向window，this.val = 10 --后console.log9
> ```
>
> ```js
> function p() {
> this.a = 1
> this.b = [1,2,this.a]
> this.c = {demo: 1}
> this.show = function () {
> 
> console.log(this.a,this.b,this.c.demo);
> }
> }
> 
> function child() {
> this.a = 2
> this.change = function () {
> this.b.push(this.a)
> this.a = this.b.length
> this.c.demo = this.a++
> }
> }
> 
> child.prototype = new p()
> var parent = new p()
> var child1 = new child()
> var child2 = new child()
> child1.a = 11
> child2.a = 12
> parent.show()
> child1.show()
> child2.show()
> child1.change()
> child2.change()
> parent.show()
> child1.show()
> child2.show()
> console.log(child1, child2);
> // 1 [ 1, 2, 1 ] 1
> // 11 [ 1, 2, 1 ] 1
> // 12 [ 1, 2, 1 ] 1
> // 1 [ 1, 2, 1 ] 1
> // 5 [ 1, 2, 1, 11, 12 ] 5
> // 6 [ 1, 2, 1, 11, 12 ] 5
> // 一个实例更改了原型的数据，另一个实例的原型也相应改变，浅拷贝
> ```
>
> ```js
> var obj = {
> func: function () {
> setTimeout(function (){
> console.log('a');
> }, 0);
> return new Promise(function (resolve) {
> console.log('b');
> resolve()
> })
> }
> }
> 
> setTimeout(() => {
> console.log('c');
> }, 0);
> 
> obj.func().then(function () {
> console.log('d');
> })
> 
> console.log('e');
> // b e d c a
> // return的promise里面的内容时同步任务
> ```
>
> ```js
> function cb(msg) {
> return function () {
> console.log(msg);
> }
> }
> setTimeout(cb('settimeout'), 1000);
> setImmediate(cb('setImmediate'))
> process.nextTick(cb('process.nexttick'))
> cb('main process')()
> // main process process.nexttick setImmediate settimeout
> ```
>
> ```js
> var a = 10, b = 11, c = 12
> function text(a) {
> a = 1
> var b = 2
> c = 3
> }
> text(10)
> console.log(a,b,c);
> // 10 11 3
> // a = 1会把text函数内的形参a覆盖掉，但是console.log的作用域是全局作用域，所以log的是全局a = 10，var b = 2也是在text函数内创建变量b=2，log的是全局变量b=11，c=3则是覆盖c但是text函数内没有c于是向外部去找找到全局变量c并覆盖，所以log的c为3
> ```
>
> ```js
> process.nextTick(function a() {
> process.nextTick(function b() {
> console.log(1);
> process.nextTick(function d() {
> console.log(2);
> })
> process.nextTick(function e() {
> console.log(3);
> })
> })
> process.nextTick(function c() {
> console.log(4);
> 
> process.nextTick(function f() {
> console.log(5);
> })
> 
> process.nextTick(function g() {
> console.log(6);
> })
> })
> })
> 
> setTimeout(function timepiut(){
> console.log('timeout');
> }, 0);
> // 1 2 3 4 5 6 timeout
> ```
>
> ```js
> w = 2
> function car(a) {
> this.b = a
> this.w = 1
> this.sheet = function () {
> console.log(this);
> }
> 
> this.sheet1 = () => {
> console.log(this);
> }
> }
> 
> const ccz = new car(100)
> ccz.sheet()
> ccz.sheet1()
> const sheet = ccz.sheet
> const sheet1 = ccz.sheet1
> sheet()
> sheet1()
> // car {b: 100, w: 1, sheet: ƒ, sheet1: ƒ}
> // car {b: 100, w: 1, sheet: ƒ, sheet1: ƒ}
> // window
> // car {b: 100, w: 1, sheet: ƒ, sheet1: ƒ}
> ```
>
> ```js
> console.log(a);
> var a = 1
> console.log(a);
> function a() { 
> }
> console.log(a);
> // [Function: a]
> // 1
> // 1
> ```
>
> ```js
> var a = 1;
> (function () {
> if(typeof a === 'undefined'){
> var a = 2
> console.log(2);
> }else{
> console.log(3);
> }
> })()
> // 2
> 
> var a = 1;
> (function () {
> if(typeof a === 'undefined'){
> console.log(2);
> }else{
> console.log(3);
> }
> })()
> // 3
> // 和预编译原理有关
> ```
>
> 块级作用域
>
> ```js
> var a = 10
> if(true){
> console.log(a);
> a = 20
> function a() {}
> a = 30
> // 块级作用域的遮蔽效果，function a只将块级作用域内的a变为function a，a=30只将块级作用域内的a赋值为30
> console.log(a);
> }
> console.log(a);
> // function a 30 20
> 
> console.log(window.a,a);
> // undefined undefined 
> if(true){
> console.log(window.a,a);
> // undefined f a() {}
> function a() {}
> console.log(window.a,a);
> // f a() {} f a() {}
> };
> console.log(window.a,a)
> // f a() {} f a() {}
> ```
>
> ```js
> var x = 1, y = 2;
> var z = function () {
> var x = 2;
> return {
>   x: x,
>   y: function (a, b) {
>       x = a + b;
>   },
>   z: function () {
>       return x;
>   }
> }
> };
> a = z();
> // a.y(x, y);
> console.log(a.z(), a.x, x);
> // 2 2 1
> 
> var x = 1, y = 2;
> var z = function () {
> var x = 2;
> return {
>   x: x,
>   y: function (a, b) {
>       x = a + b;
>   },
>   z: function () {
>       return x;
>   }
> }
> };
> a = z();
> a.y(x, y);
> console.log(a.z(), a.x, x);
> // 3 2 1
> ```
>
> ```js
> function A() {
> 
> }
> 
> function B(a) {
> this.a = a
> }
> 
> function C(a) {
> if(a){
>   this.a = a
> }
> }
> 
> A.prototype.a = 1
> B.prototype.a = 1
> C.prototype.a = 1
> 
> console.log(new A().a);
> console.log(new B().a);
> console.log(new C(2).a);
> // 1 undefined 2
> ```
>
> ```js
> inner ='window'
> function say() {
>  console.log(inner);
>  console.log(this.inner);
> }
> 
> var obj1 = (function() {
>  var inner = '1-1';
>  return {// TODO 1
>     inner: '1-2',
>     say: function() {
>       console.log(inner);
>       console.log(this.inner);
>     }
>   }
> })();
> 
> var obj2 = (function() {
>    var inner = '2-1';
>    return {
>       inner: '2-2',
>       say: function() {
>           console.log(inner);
>            console.log(this.inner);
>        }
>    }
> })();
> 
> say()  // window window
> obj1.say(); // 1-1 1-2
> obj2.say(); // 2-1 2-2
> obj1.say = say; // 此处重新定义了obj1.say，更改了作用域链
> obj1.say(); // window 1-2
> obj1.say = obj2.say; // 此处重新定义了obj1.say，更改了作用域链
> obj1.say(); // 2-1 1-2
> // 闭包作用域和静态作用域问题，闭包会导致查找变量时忽略自身，直接去找外层函数内的变量
> // 静态作用域决定了作用域链由函数定义的位置决定而不是调用位置
> ```
>
> ```js
> var a = 1
> setTimeout(function(){
>     console.log(a++);
> }, 0);
> new Promise(function executor(resolve) {
>     console.log(a++);
>     for(var i = 0;i < 1000; i++){
>         resolve(a++)
>     }
>     console.log(a++);
> }).then(function (a) {
>     console.log(a++);
> })
> console.log(a++);
> // 1 1002 1003 2 1004
> ```
>
> ```js
> function A() {}
> A.prototype.x = 10
> var a1 = new A()
> A.prototype = {x:20,y:30}
> var a2 = new A()
> console.log(a1.x,a1.y,a2.x,a2.y);
> // 10 undefined 20 30
> ```
>
> ![image-20220913123636390](images/image-20220913123636390.png)
>
> ```js
> var length = 10;
> function fn() {
>     console.log(this.length);
> }
>  
> var obj = {
>   length: 5,
>   method: function(fn) {
>     fn();
>     arguments[0]();
>   }
> };
>  
> obj.method(fn, 1);
> // 10 2
> ```
>
> ![image-20220913165008783](images/image-20220913165008783.png)